[{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"introduction-to-least-squares-separate-lss","dir":"Articles","previous_headings":"","what":"Introduction to Least Squares Separate (LSS)","title":"Getting Started with fmrilss","text":"fmrilss package provides fast flexible implementation Least Squares Separate (LSS) modeling approach, first proposed Mumford et al. (2012). LSS powerful method analyzing event-related fMRI data, especially studies involving multivariate pattern analysis (MVPA) functional connectivity. core idea LSS estimate separate GLM trial. given trial, model includes: regressor trial interest. single regressor trials combined. Experimental regressors want model estimate, trial-wise (e.g., intercept, condition effects, block effects). Nuisance regressors want remove data analysis (e.g., motion parameters, physiological noise). process repeated every trial, yielding unique beta estimate one.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"the-lss-function","dir":"Articles","previous_headings":"","what":"The lss() Function","title":"Getting Started with fmrilss","text":"main entry point package lss() function, clean modern interface: Y: data matrix (timepoints x voxels). X: trial design matrix (timepoints x trials). Z: matrix experimental regressors want model get beta estimates , trial-wise (e.g., intercept, condition effects, block effects). Defaults intercept NULL. Nuisance: matrix nuisance regressors projected analysis (e.g., motion parameters, physiological noise). method: computational backend use. Options range simple naive R loop highly optimized parallelized \"cpp_optimized\" engine.","code":"lss(Y, X, Z = NULL, Nuisance = NULL, method = \"r_optimized\")"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"a-practical-example","dir":"Articles","previous_headings":"","what":"A Practical Example","title":"Getting Started with fmrilss","text":"Let’s walk complete example, generating data running analysis.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"load-the-package-and-prepare-data","dir":"Articles","previous_headings":"A Practical Example","what":"1. Load the Package and Prepare Data","title":"Getting Started with fmrilss","text":"First, load fmrilss set parameters.","code":"library(fmrilss)  set.seed(42) n_timepoints <- 150 n_trials <- 12 n_voxels <- 25"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"create-design-matrices","dir":"Articles","previous_headings":"A Practical Example","what":"2. Create Design Matrices","title":"Getting Started with fmrilss","text":"Next, create core components model. Trial Matrix (X): matrix column represents predicted BOLD response single trial. Experimental Regressors (Z): matrix experimental regressors want model get beta estimates , trial-wise. might include condition effects, block effects, experimental factors vary across session trial--trial. Nuisance Matrix: Regressors want remove data modeling, motion parameters physiological noise.","code":"# Trial design matrix (X) X <- matrix(0, n_timepoints, n_trials) onsets <- seq(from = 10, to = n_timepoints - 12, length.out = n_trials) for(i in 1:n_trials) {   X[onsets[i]:(onsets[i] + 5), i] <- 1 }  # Experimental regressors (Z) - intercept and condition effects # These are regressors we want to model and get estimates for, but not trial-wise Z <- cbind(Intercept = 1, LinearTrend = scale(1:n_timepoints, center = TRUE, scale = FALSE))  # Nuisance regressors - e.g., 6 motion parameters Nuisance <- matrix(rnorm(n_timepoints * 6), n_timepoints, 6)"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"simulate-data-y","dir":"Articles","previous_headings":"A Practical Example","what":"3. Simulate Data (Y)","title":"Getting Started with fmrilss","text":"Now, ’ll generate synthetic data matrix Y includes signals regressors plus random noise.","code":"# Simulate effects for each component true_trial_betas <- matrix(rnorm(n_trials * n_voxels, 0, 1.2), n_trials, n_voxels) true_fixed_effects <- matrix(rnorm(2 * n_voxels, c(5, -0.1), 0.5), 2, n_voxels) true_nuisance_effects <- matrix(rnorm(6 * n_voxels, 0, 2), 6, n_voxels)  # Combine signals and add noise Y <- (Z %*% true_fixed_effects) +       (X %*% true_trial_betas) +      (Nuisance %*% true_nuisance_effects) +      matrix(rnorm(n_timepoints * n_voxels, 0, 1), n_timepoints, n_voxels)"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"run-the-lss-analysis","dir":"Articles","previous_headings":"A Practical Example","what":"4. Run the LSS Analysis","title":"Getting Started with fmrilss","text":"data prepared, can now run lss analysis.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"basic-usage","dir":"Articles","previous_headings":"A Practical Example > 4. Run the LSS Analysis","what":"Basic Usage","title":"Getting Started with fmrilss","text":"provide data Y trial matrix X, function automatically include intercept.","code":"beta_basic <- lss(Y, X) # The result is a trials-by-voxels matrix dim(beta_basic) #> [1] 12 25"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"including-experimental-regressors-and-nuisance-regressors","dir":"Articles","previous_headings":"A Practical Example > 4. Run the LSS Analysis","what":"Including Experimental Regressors and Nuisance Regressors","title":"Getting Started with fmrilss","text":"realistic analysis, include Z Nuisance matrices. nuisance regressors projected Y X trial-wise GLMs estimated, experimental regressors Z included every trial-wise GLM get beta estimates.","code":"beta_full <- lss(Y, X, Z = Z, Nuisance = Nuisance) # The output dimensions remain the same dim(beta_full) #> [1] 12 25"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"choosing-a-high-performance-method","dir":"Articles","previous_headings":"A Practical Example","what":"5. Choosing a High-Performance Method","title":"Getting Started with fmrilss","text":"default R implementation well-optimized, C++ backend offers significant speedup, especially large datasets. also parallelized OpenMP use multiple CPU cores. use , simply set method = \"cpp_optimized\". makes easy switch readable R implementation high-performance C++ engine without changing code.","code":"# Run the same analysis with the high-performance C++ engine beta_fast <- lss(Y, X, Z = Z, Nuisance = Nuisance, method = \"cpp_optimized\")  # The results are numerically identical to the R version all.equal(beta_full, beta_fast, tolerance = 1e-8) #> [1] TRUE"},{"path":"https://bbuchsbaum.github.io/fmrilss/articles/getting_started.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Getting Started with fmrilss","text":"Mumford, J. ., Turner, B. O., Ashby, F. G., & Poldrack, R. . (2012). Deconvolving BOLD activation event-related designs multivoxel pattern classification analyses. NeuroImage, 59(3), 2636-2643.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brad Buchsbaum. Maintainer.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Buchsbaum B (2025). fmrilss: Least Squares Separate (LSS) Analysis fMRI Data. R package version 0.1.0, https://bbuchsbaum.github.io/fmrilss/.","code":"@Manual{,   title = {fmrilss: Least Squares Separate (LSS) Analysis for fMRI Data},   author = {Brad Buchsbaum},   year = {2025},   note = {R package version 0.1.0},   url = {https://bbuchsbaum.github.io/fmrilss/}, }"},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"fmrilss","dir":"","previous_headings":"","what":"Least Squares Separate (LSS) Analysis for fMRI Data","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"Least Squares Separate (LSS) Analysis fMRI Data.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"fmrilss package provides efficient flexible implementation Least Squares Separate (LSS) method fMRI analysis, proposed Mumford et al. (2012). approach models trial separate GLM, making powerful technique multivariate pattern analysis (MVPA) connectivity studies trial-specific estimates needed. package offers multiple backends, simple reference implementation highly optimized, parallel C++ engine, accessible clean, unified interface.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"Five Implementations: Includes highly optimized C++ version, optimized R version, standard vectorized R C++ versions, simple R loop testing validation. Parallel Processing: optimized C++ version uses OpenMP multi-threaded execution maximize performance modern hardware. Flexible & Modern Interface: clean lss(Y, X, Z, Nuisance) signature powerful intuitive. Nuisance Regression: Built-support projecting nuisance regressors (e.g., motion parameters, physiological noise) LSS analysis. CRAN-Compliant: Built portable configurations suitable CRAN submission.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"can install development version fmrilss GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"bbuchsbaum/fmrilss\")"},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"primary function lss(), takes data Y, trial design X, experimental regressors Z, optional nuisance regressors.","code":"library(fmrilss)  # 1. Generate synthetic data set.seed(123) n_timepoints <- 120 n_trials <- 15 n_voxels <- 50  # Trial design matrix (X): one column per trial X <- matrix(0, n_timepoints, n_trials) onsets <- seq(from = 5, to = n_timepoints - 10, length.out = n_trials) for(i in 1:n_trials) {   X[onsets[i]:(onsets[i] + 4), i] <- 1 } colnames(X) <- paste0(\"Trial_\", 1:n_trials)  # Experimental regressors (Z): intercept and condition-specific effects # These are experimental regressors we want to model and get beta estimates for, # but not trial-wise (e.g., condition differences, block effects) Z <- cbind(Intercept = 1, LinearTrend = scale(1:n_timepoints, center = TRUE, scale = FALSE))  # Nuisance regressors: e.g., 6 motion parameters Nuisance <- matrix(rnorm(n_timepoints * 6), n_timepoints, 6)  # Data (Y): timepoints x voxels # (Simulate some effects for demonstration) true_betas <- matrix(rnorm(n_trials * n_voxels, 0, 1.5), n_trials, n_voxels) Y <- Z %*% matrix(c(10, -0.2), 2, n_voxels) +       X %*% true_betas +      Nuisance %*% matrix(rnorm(6 * n_voxels, 0, 2), 6, n_voxels) +      matrix(rnorm(n_timepoints * n_voxels, 0, 0.8), n_timepoints, n_voxels) colnames(Y) <- paste0(\"Voxel_\", 1:n_voxels)   # 2. Run LSS analysis  # Example 1: Basic LSS with default intercept # If Z is NULL, an intercept is automatically added. beta_estimates <- lss(Y, X)  # Example 2: LSS with experimental regressors (intercept + condition effects) beta_fixed <- lss(Y, X, Z = Z)  # Example 3: LSS with experimental regressors and nuisance regression beta_clean <- lss(Y, X, Z = Z, Nuisance = Nuisance)  # Example 4: Use the super-fast, parallelized C++ implementation beta_fast <- lss(Y, X, Z = Z, Nuisance = Nuisance, method = \"cpp_optimized\")  # The result is a (trials x voxels) matrix of beta estimates print(dim(beta_fast)) #> [1] 15 50 print(beta_fast[1:5, 1:4])"},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"Mumford, J. ., Turner, B. O., Ashby, F. G., & Poldrack, R. . (2012). Deconvolving BOLD activation event-related designs multivoxel pattern classification analyses. NeuroImage, 59(3), 2636-2643.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Least Squares Separate (LSS) Analysis for fMRI Data","text":"GPL-3","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"current-situation","dir":"","previous_headings":"","what":"Current Situation","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"examining LSS implementations, ’s happens Z (experimental regressor) beta estimates:","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"what-all-implementations-currently-do","dir":"","previous_headings":"Current Situation","what":"What All Implementations Currently Do:","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Combine Z nuisance regressors single confound matrix: X_confounds = cbind(Z, Nuisance) Project combined confounds Y trial regressors (X) Compute trial-wise betas projected data Return trial betas (T × V matrix) Discard Z beta estimates computed projection step","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"key-finding","dir":"","previous_headings":"Current Situation","what":"Key Finding:","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Z beta estimates computed projection step implementations, ’re thrown away. need capture return .","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"id_1-modify-the-projection-step","dir":"","previous_headings":"Proposed Solution","what":"1. Modify the Projection Step","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Instead treating Z Nuisance single confound matrix, need :","code":"# Current approach: X_confounds <- cbind(Z, Nuisance)  # Combine everything # Project out all confounds together  # Proposed approach: # Step 1: Project out Nuisance from Y, X, and Z if (!is.null(Nuisance)) {   Y_clean <- residualize(Y, Nuisance)   X_clean <- residualize(X, Nuisance)    Z_clean <- residualize(Z, Nuisance) } else {   Y_clean <- Y   X_clean <- X   Z_clean <- Z }  # Step 2: Fit Z to clean data and get Z betas Z_betas <- solve(t(Z_clean) %*% Z_clean) %*% t(Z_clean) %*% Y_clean  # Step 3: Project out Z from Y and X for trial estimation Y_final <- Y_clean - Z_clean %*% Z_betas X_final <- residualize(X_clean, Z_clean)  # Step 4: Compute trial betas on final projected data trial_betas <- lss_computation(Y_final, X_final)"},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"id_2-return-structure","dir":"","previous_headings":"Proposed Solution","what":"2. Return Structure","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Change return value simple matrix list:","code":"# Current return: matrix(trial_betas)  # T × V  # Proposed return: list(   trial_betas = matrix(trial_betas),    # T × V (trial estimates)   Z_betas = matrix(Z_betas),            # F × V (experimental regressor estimates)   trials = rownames(trial_betas),       # Trial names   voxels = colnames(trial_betas),       # Voxel names   regressors = colnames(Z)              # Z regressor names )"},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"id_3-backward-compatibility","dir":"","previous_headings":"Proposed Solution","what":"3. Backward Compatibility","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Provide parameter control return format:","code":"lss(..., return_format = c(\"matrix\", \"list\"))  # return_format = \"matrix\": current behavior (trial betas only) # return_format = \"list\": new behavior (both trial and Z betas)"},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"phase-1-core-infrastructure","dir":"","previous_headings":"Implementation Plan","what":"Phase 1: Core Infrastructure","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Create helper functions new projection workflow Update main lss() function support new return format Modify .lss_r_optimized() reference implementation","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"phase-2-update-all-implementations","dir":"","previous_headings":"Implementation Plan","what":"Phase 2: Update All Implementations","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Update .lss_naive() - easiest modify test Update .lss_r_vectorized() lss_fast() Update .lss_cpp() related C++ functions Update .lss_cpp_optimized() lss_fused_optim_cpp()","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"phase-3-c-implementation-updates","dir":"","previous_headings":"Implementation Plan","what":"Phase 3: C++ Implementation Updates","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Modify compute_residuals_cpp() handle separate projection steps Create new C++ functions Z beta computation Update lss_fused_optim_cpp() new workflow","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"phase-4-testing-and-documentation","dir":"","previous_headings":"Implementation Plan","what":"Phase 4: Testing and Documentation","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Create comprehensive tests Z beta estimates Update documentation examples Add vignette section interpreting Z betas","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"helper-functions-needed","dir":"","previous_headings":"Specific Implementation Details","what":"Helper Functions Needed:","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"","code":"# Residualize Y against X: Y - X %*% solve(t(X) %*% X) %*% t(X) %*% Y .residualize <- function(Y, X) {   if (is.null(X)) return(Y)   XtX_inv <- chol2inv(chol(crossprod(X)))   Y - X %*% (XtX_inv %*% crossprod(X, Y)) }  # Compute beta estimates: solve(t(X) %*% X) %*% t(X) %*% Y .compute_betas <- function(Y, X) {   XtX_inv <- chol2inv(chol(crossprod(X)))   XtX_inv %*% crossprod(X, Y) }  # Format return value based on return_format .format_lss_output <- function(trial_betas, Z_betas = NULL,                                 return_format = \"matrix\", ...) {   if (return_format == \"matrix\") {     return(trial_betas)   } else {     return(list(       trial_betas = trial_betas,       Z_betas = Z_betas,       ...     ))   } }"},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"c-functions-needed","dir":"","previous_headings":"Specific Implementation Details","what":"C++ Functions Needed:","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"","code":"// Separate projection for nuisance vs experimental regressors List project_separate_cpp(const arma::mat& Y,                           const arma::mat& X_trials,                           const arma::mat& Z_experimental,                           const arma::mat& Nuisance);  // Compute beta estimates arma::mat compute_betas_cpp(const arma::mat& Y, const arma::mat& X);"},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"benefits","dir":"","previous_headings":"","what":"Benefits","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Complete Information: Users get beta estimates computed LSS Experimental Design Insights: Can examine condition effects, block effects, etc. Debugging Validation: Can verify nuisance regression worked properly Flexibility: Users can choose information need Backward Compatibility: Existing code continues work unchanged","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"considerations","dir":"","previous_headings":"","what":"Considerations","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Memory Usage: Returning Z betas increases memory usage, typically Z columns API Consistency: Need decide best return structure Performance: new projection workflow may slightly slower informative Documentation: Need clear examples use Z betas","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/proposal_z_betas.html","id":"recommended-first-steps","dir":"","previous_headings":"","what":"Recommended First Steps","title":"Proposal: Return Z Beta Estimates in LSS Functions","text":"Implement helper functions Modify .lss_r_optimized() prototype return_format parameter Create comprehensive tests comparing old vs new approaches Get user feedback proposed return structure Roll implementations design validated","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/MixedWorkspace.html","id":null,"dir":"Reference","previous_headings":"","what":"Mixed Model Workspace for Optimized Computation — MixedWorkspace","title":"Mixed Model Workspace for Optimized Computation — MixedWorkspace","text":"Stores precomputed matrices decompositions can reused across multiple voxels avoid repeated expensive computations.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/dot-mixed_solve_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mixed Model Solver using C++ — .mixed_solve_cpp","title":"Mixed Model Solver using C++ — .mixed_solve_cpp","text":"C++ implementation mixed model solver. function typically called main `mixed_solve` function rather directly.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/dot-mixed_solve_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mixed Model Solver using C++ — .mixed_solve_cpp","text":"","code":".mixed_solve_cpp(   Y,   X = NULL,   Z = NULL,   K = NULL,   method = \"REML\",   bounds = c(1e-09, 1e+09),   SE = FALSE,   return_Hinv = FALSE )"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/dot-mixed_solve_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mixed Model Solver using C++ — .mixed_solve_cpp","text":"Y Response vector. X Design matrix fixed effects (default: intercept ). Z Design matrix random effects (default: identity matrix). K Kinship matrix (default: identity matrix). method Optimization method, either \"REML\" \"ML\". bounds Bounds optimizer. SE Logical, whether return standard errors. return_Hinv Logical, whether return inverse H.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/dot-mixed_solve_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mixed Model Solver using C++ — .mixed_solve_cpp","text":"list mixed model results.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fast_reml_lambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast analytical REML estimation for single variance component — fast_reml_lambda","title":"Fast analytical REML estimation for single variance component — fast_reml_lambda","text":"single variance component model, REML estimate λ = σe²/σu² closed-form solution can computed efficiently.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fast_reml_lambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast analytical REML estimation for single variance component — fast_reml_lambda","text":"omega Transformed response vector Q'y theta Transformed eigenvalues tol Convergence tolerance Newton iterations max_iter Maximum Newton iterations","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fast_reml_lambda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast analytical REML estimation for single variance component — fast_reml_lambda","text":"Estimated variance ratio λ","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fmrilss-package.html","id":null,"dir":"Reference","previous_headings":"","what":"fmrilss: Least Squares Separate (LSS) Analysis for fMRI Data — fmrilss-package","title":"fmrilss: Least Squares Separate (LSS) Analysis for fMRI Data — fmrilss-package","text":"package implements efficient least squares separate (LSS) analysis functional magnetic resonance imaging (fMRI) data. LSS used estimate trial--trial activation patterns event-related fMRI designs.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fmrilss-package.html","id":"main-functions","dir":"Reference","previous_headings":"","what":"Main functions","title":"fmrilss: Least Squares Separate (LSS) Analysis for fMRI Data — fmrilss-package","text":"lss: Main function performing LSS analysis lss_naive: Naive LSS implementation reference project_confounds: R implementation projecting confounds project_confounds_cpp: Fast C++ confound projection lss_beta_cpp: Vectorized C++ LSS beta computation get_data_matrix: Helper function data extraction","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fmrilss-package.html","id":"features","dir":"Reference","previous_headings":"","what":"Features","title":"fmrilss: Least Squares Separate (LSS) Analysis for fMRI Data — fmrilss-package","text":"Optimized C++ implementation using vectorized matrix algebra Memory-efficient projection without forming Q matrices Cholesky decomposition numerical stability Fallback R implementation QR decomposition Support various design matrix configurations Robust numerical handling edge cases OpenMP support multi-core processing","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/fmrilss-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fmrilss: Least Squares Separate (LSS) Analysis for fMRI Data — fmrilss-package","text":"Name <.email@example.com>","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/get_data_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Data Matrix from Dataset — get_data_matrix","title":"Extract Data Matrix from Dataset — get_data_matrix","text":"Helper function extract data matrix various dataset formats. placeholder customized based data format.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/get_data_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Data Matrix from Dataset — get_data_matrix","text":"","code":"get_data_matrix(dset)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/get_data_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Data Matrix from Dataset — get_data_matrix","text":"dset Dataset object (format depends specific use case)","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/get_data_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Data Matrix from Dataset — get_data_matrix","text":"numeric matrix rows timepoints columns voxels","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/list_to_workspace.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert R list back to MixedWorkspace — list_to_workspace","title":"Convert R list back to MixedWorkspace — list_to_workspace","text":"Convert R list back MixedWorkspace","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Least Squares All (LSA) Analysis — lsa","title":"Least Squares All (LSA) Analysis — lsa","text":"Performs standard multiple regression analysis trial regressors fitted simultaneously. provides reference comparison Least Squares Separate (LSS) approach.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Least Squares All (LSA) Analysis — lsa","text":"","code":"lsa(Y, X, Z = NULL, Nuisance = NULL, method = c(\"r\", \"cpp\"))"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Least Squares All (LSA) Analysis — lsa","text":"Y numeric matrix rows timepoints columns voxels/features. dependent variable data. X numeric matrix rows timepoints columns trial-specific regressors. column represents single trial event. Z numeric matrix nuisance regressors (e.g., motion parameters, drift terms). Defaults NULL. Nuisance alias Z, provided consistency LSS interface. Z Nuisance provided, Z takes precedence. method Character string specifying computational method: \"r\" - Pure R implementation using lm.fit \"cpp\" - C++ implementation better performance","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lsa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Least Squares All (LSA) Analysis — lsa","text":"numeric matrix size T × V containing beta estimates   trial regressor (rows) voxel (columns).","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lsa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Least Squares All (LSA) Analysis — lsa","text":"LSA fits model: Y = X*beta + Z*gamma + error, trial regressors X estimated simultaneously. contrast LSS, fits trial separately treating trials nuisance regressors.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lsa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Least Squares All (LSA) Analysis — lsa","text":"","code":"# Generate example data n_timepoints <- 100 n_trials <- 10 n_voxels <- 50  # Create trial design matrix X <- matrix(0, n_timepoints, n_trials) for(i in 1:n_trials) {   start <- (i-1) * 8 + 1   if(start + 5 <= n_timepoints) {     X[start:(start+5), i] <- 1   } }  # Create data with some signal Y <- matrix(rnorm(n_timepoints * n_voxels), n_timepoints, n_voxels) true_betas <- matrix(rnorm(n_trials * n_voxels, 0, 0.5), n_trials, n_voxels) for(i in 1:n_trials) {   Y <- Y + X[, i] %*% matrix(true_betas[i, ], 1, n_voxels) }  # Run LSA analysis beta_estimates <- lsa(Y, X)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":null,"dir":"Reference","previous_headings":"","what":"Least Squares Separate (LSS) Analysis — lss","title":"Least Squares Separate (LSS) Analysis — lss","text":"Computes trial-wise beta estimates using Least Squares Separate approach Mumford et al. (2012). method fits separate GLM trial, trial interest trials separate regressors.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Least Squares Separate (LSS) Analysis — lss","text":"","code":"lss(   Y,   X,   Z = NULL,   Nuisance = NULL,   method = c(\"r_optimized\", \"cpp_optimized\", \"r_vectorized\", \"cpp\", \"naive\"),   block_size = 96 )"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Least Squares Separate (LSS) Analysis — lss","text":"Y numeric matrix size n × V n number timepoints V number voxels/variables X numeric matrix size n × T T number trials. column represents design one trial Z numeric matrix size n × F representing experimental regressors include trial-wise models. regressors want model get beta estimates , trial-wise (e.g., intercept, condition effects, block effects). NULL, intercept-design used. Defaults NULL Nuisance numeric matrix size n × N representing nuisance regressors projected LSS analysis (e.g., motion parameters, physiological noise). NULL, nuisance projection performed. Defaults NULL method Character string specifying implementation use. Options : \"r_optimized\" - Optimized R implementation (recommended, default) \"cpp_optimized\" - Optimized C++ implementation parallel support \"r_vectorized\" - Standard R vectorized implementation \"cpp\" - Standard C++ implementation \"naive\" - Simple loop-based R implementation (testing) block_size integer specifying voxel block size parallel processing, applicable `method = \"cpp_optimized\"`. Defaults 96.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Least Squares Separate (LSS) Analysis — lss","text":"numeric matrix size T × V containing trial-wise beta estimates.   Note: Currently returns estimates trial regressors (X). Beta   estimates experimental regressors (Z) computed returned.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Least Squares Separate (LSS) Analysis — lss","text":"LSS approach fits separate GLM trial, model includes: trial interest (column X) trials combined (sum columns X) Experimental regressors (Z matrix) - modeled get beta estimates trial-wise Nuisance regressors provided, first projected Y X using standard linear regression residualization.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Least Squares Separate (LSS) Analysis — lss","text":"Mumford, J. ., Turner, B. O., Ashby, F. G., & Poldrack, R. . (2012). Deconvolving BOLD activation event-related designs multivoxel pattern classification analyses. NeuroImage, 59(3), 2636-2643.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Least Squares Separate (LSS) Analysis — lss","text":"","code":"# Generate example data n_timepoints <- 100 n_trials <- 10 n_voxels <- 50  # Create trial design matrix X <- matrix(0, n_timepoints, n_trials) for(i in 1:n_trials) {   start <- (i-1) * 8 + 1   if(start + 5 <= n_timepoints) {     X[start:(start+5), i] <- 1   } }  # Create data with some signal Y <- matrix(rnorm(n_timepoints * n_voxels), n_timepoints, n_voxels) true_betas <- matrix(rnorm(n_trials * n_voxels, 0, 0.5), n_trials, n_voxels) for(i in 1:n_trials) {   Y <- Y + X[, i] %*% matrix(true_betas[i, ], 1, n_voxels) }  # Run LSS analysis beta_estimates <- lss(Y, X)  # With experimental regressors (intercept + condition effects) Z <- cbind(1, scale(1:n_timepoints)) beta_estimates_with_regressors <- lss(Y, X, Z = Z)  # With nuisance regression (motion parameters) Nuisance <- matrix(rnorm(n_timepoints * 6), n_timepoints, 6) beta_estimates_clean <- lss(Y, X, Z = Z, Nuisance = Nuisance)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_beta_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","title":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","text":"Fast C++ implementation least squares separate (LSS) beta estimation using vectorized matrix operations. Computes trial betas single pass without loops.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_beta_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","text":"","code":"lss_beta_cpp(C_projected, Y_projected)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_beta_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","text":"C_projected Projected trial regressors (n x T) project_confounds_cpp Y_projected Projected data (n x V) project_confounds_cpp","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_beta_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","text":"Beta matrix (T x V) LSS estimates trial voxel","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_beta_cpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","text":"vectorized implementation computes LSS betas simultaneously using matrix algebra. significantly faster per-trial loops automatically benefits BLAS multithreading. algorithm handles numerical edge cases setting problematic denominators NaN. best performance large datasets, ensure R installation uses optimized BLAS (like OpenBLAS Intel MKL).","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_beta_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized LSS Beta Computation Using C++ — lss_beta_cpp","text":"","code":"if (FALSE) { # \\dontrun{ # After projecting out confounds result <- project_confounds_cpp(X_confounds, Y_data, C_trials) betas <- lss_beta_cpp(result$Q_dmat_ran, result$residual_data) } # }"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_cpp_optimized.html","id":null,"dir":"Reference","previous_headings":"","what":"A wrapper for the optimized C++ LSS implementation — lss_cpp_optimized","title":"A wrapper for the optimized C++ LSS implementation — lss_cpp_optimized","text":"wrapper optimized C++ LSS implementation","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_cpp_optimized.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A wrapper for the optimized C++ LSS implementation — lss_cpp_optimized","text":"","code":"lss_cpp_optimized(Y, bdes)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_cpp_optimized.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A wrapper for the optimized C++ LSS implementation — lss_cpp_optimized","text":"Y voxel time data matrix bdes block design list created block_design","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_cpp_optimized.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A wrapper for the optimized C++ LSS implementation — lss_cpp_optimized","text":"matrix beta estimates","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_fused_optim_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Fused Single-Pass LSS Solver (C++) — lss_fused_optim_cpp","title":"Fused Single-Pass LSS Solver (C++) — lss_fused_optim_cpp","text":"function computes Least Squares-Separate (LSS) beta estimates using memory-efficient, single-pass algorithm. fuses projection estimation steps, processing voxels parallel blocks maximize cache efficiency.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_fused_optim_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fused Single-Pass LSS Solver (C++) — lss_fused_optim_cpp","text":"","code":"lss_fused_optim_cpp(X, Y, C, block_size = 96L)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_fused_optim_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fused Single-Pass LSS Solver (C++) — lss_fused_optim_cpp","text":"X nuisance regressor matrix (confounds). Y data matrix (e.g., fMRI data). C trial-wise design matrix. block_size number voxels process parallel block.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_fused_optim_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fused Single-Pass LSS Solver (C++) — lss_fused_optim_cpp","text":"matrix LSS beta estimates.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_naive.html","id":null,"dir":"Reference","previous_headings":"","what":"Naive Least Squares Separate (LSS) Analysis — lss_naive","title":"Naive Least Squares Separate (LSS) Analysis — lss_naive","text":"Performs LSS analysis using naive approach trial model fit separately. conceptually simplest implementation less efficient optimized lss function.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_naive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Naive Least Squares Separate (LSS) Analysis — lss_naive","text":"","code":"lss_naive(Y = NULL, bdes, dset = NULL)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_naive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Naive Least Squares Separate (LSS) Analysis — lss_naive","text":"Y numeric matrix rows timepoints columns voxels/features. NULL, function attempt extract data dset. bdes list containing design matrices components: dmat_base: Base design matrix (e.g., intercept, drift terms) dmat_fixed: Fixed effects design matrix (optional) dmat_ran: Random/trial design matrix LSS analysis fixed_ind: Indices fixed effects (optional) dset Optional dataset object. provided Y NULL, data extracted using get_data_matrix.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_naive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Naive Least Squares Separate (LSS) Analysis — lss_naive","text":"numeric matrix dimensions (n_events x n_voxels) containing LSS beta estimates trial voxel.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_naive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Naive Least Squares Separate (LSS) Analysis — lss_naive","text":"function implements naive LSS approach trial, separate GLM fitted includes: base regressors (intercept, drift, etc.) fixed effects regressors () current trial's regressor trial design matrix less efficient optimized lss function, implementation conceptually simpler can serve reference validation purposes.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_naive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Naive Least Squares Separate (LSS) Analysis — lss_naive","text":"","code":"if (FALSE) { # \\dontrun{ # Using same setup as lss() examples beta_estimates_naive <- lss_naive(Y = Y, bdes = bdes)  # Compare with optimized version beta_estimates_fast <- lss(Y = Y, bdes = bdes) max(abs(beta_estimates_naive - beta_estimates_fast)) } # }"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_optimized.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized LSS Analysis (Pure R) — lss_optimized","title":"Optimized LSS Analysis (Pure R) — lss_optimized","text":"optimized version LSS analysis avoids creating large intermediate matrices, providing significant speedup lower memory usage pure R implementation.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_optimized.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized LSS Analysis (Pure R) — lss_optimized","text":"","code":"lss_optimized(Y = NULL, bdes, dset = NULL, use_cpp = TRUE)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_optimized.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized LSS Analysis (Pure R) — lss_optimized","text":"Y numeric matrix rows timepoints columns voxels/features. bdes list containing design matrices. dset Optional dataset object. use_cpp Logical. TRUE (default), uses C++ implementation. FALSE, uses new optimized R implementation.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/lss_optimized.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized LSS Analysis (Pure R) — lss_optimized","text":"numeric matrix LSS beta estimates.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_multi_voxel_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized multi-voxel mixed model estimation — mixed_multi_voxel_cpp","title":"Optimized multi-voxel mixed model estimation — mixed_multi_voxel_cpp","text":"Uses precomputed workspace parallel processing efficiently estimate mixed models across many voxels.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_multi_voxel_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized multi-voxel mixed model estimation — mixed_multi_voxel_cpp","text":"","code":"mixed_multi_voxel_cpp(Y, ws_list, compute_se = FALSE, n_threads = 0L)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_multi_voxel_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized multi-voxel mixed model estimation — mixed_multi_voxel_cpp","text":"Y Response matrix (n × V) V number voxels ws_list Precomputed workspace (R list) compute_se Whether compute standard errors n_threads Number OpenMP threads (0 = auto)","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_multi_voxel_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized multi-voxel mixed model estimation — mixed_multi_voxel_cpp","text":"List matrices estimates across voxels","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute.html","id":null,"dir":"Reference","previous_headings":"","what":"Precompute Workspace for Optimized Mixed Model — mixed_precompute","title":"Precompute Workspace for Optimized Mixed Model — mixed_precompute","text":"Performs expensive matrix computations depend response vector, allowing efficient reuse across multiple voxels.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precompute Workspace for Optimized Mixed Model — mixed_precompute","text":"","code":"mixed_precompute(X, Z, K = NULL)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precompute Workspace for Optimized Mixed Model — mixed_precompute","text":"X Fixed effects design matrix (n × p) Z Random effects design matrix (n × q) K Kinship/covariance matrix random effects (q × q)","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precompute Workspace for Optimized Mixed Model — mixed_precompute","text":"Workspace object use mixed_solve_optimized","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute_workspace.html","id":null,"dir":"Reference","previous_headings":"","what":"Precompute workspace for mixed model optimization — mixed_precompute_workspace","title":"Precompute workspace for mixed model optimization — mixed_precompute_workspace","text":"Performs expensive computations depend response vector y, can reused across multiple voxels.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute_workspace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precompute workspace for mixed model optimization — mixed_precompute_workspace","text":"","code":"mixed_precompute_workspace(X, Z, K)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute_workspace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precompute workspace for mixed model optimization — mixed_precompute_workspace","text":"X Fixed effects design matrix (n × p) Z Random effects design matrix (n × q) K Kinship/covariance matrix random effects (q × q)","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_precompute_workspace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precompute workspace for mixed model optimization — mixed_precompute_workspace","text":"MixedWorkspace object containing precomputed matrices","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_single_voxel_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast single-voxel mixed model estimation using precomputed workspace — mixed_single_voxel_cpp","title":"Fast single-voxel mixed model estimation using precomputed workspace — mixed_single_voxel_cpp","text":"Fast single-voxel mixed model estimation using precomputed workspace","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_single_voxel_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast single-voxel mixed model estimation using precomputed workspace — mixed_single_voxel_cpp","text":"","code":"mixed_single_voxel_cpp(y, ws_list, compute_se = FALSE)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_single_voxel_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast single-voxel mixed model estimation using precomputed workspace — mixed_single_voxel_cpp","text":"y Response vector single voxel ws_list Precomputed workspace (R list) compute_se Whether compute standard errors","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_single_voxel_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast single-voxel mixed model estimation using precomputed workspace — mixed_single_voxel_cpp","text":"List beta, u, Vu, Ve, optionally standard errors","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve.html","id":null,"dir":"Reference","previous_headings":"","what":"Mixed Model Solver — mixed_solve","title":"Mixed Model Solver — mixed_solve","text":"Solves mixed models random effects using REML ML estimation. function provides unified interface mixed model estimation, similar lss/lsa functions package.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mixed Model Solver — mixed_solve","text":"","code":"mixed_solve(   Y,   X = NULL,   Z = NULL,   K = NULL,   Nuisance = NULL,   method = c(\"REML\", \"ML\"),   bounds = c(1e-09, 1e+09),   SE = FALSE,   return_Hinv = FALSE )  mixed_solve_cpp(   Y,   X = NULL,   Z = NULL,   K = NULL,   Nuisance = NULL,   method = c(\"REML\", \"ML\"),   bounds = c(1e-09, 1e+09),   SE = FALSE,   return_Hinv = FALSE )"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mixed Model Solver — mixed_solve","text":"Y Response vector matrix. matrix, column treated separate response variable. X Design matrix fixed effects. NULL, defaults intercept . Z Design matrix random effects. NULL, defaults identity matrix. K Kinship matrix random effects. NULL, defaults identity matrix. Nuisance alias X, provided consistency lss/lsa interface. X Nuisance provided, X takes precedence. method Character string specifying estimation method: \"REML\" - Restricted Maximum Likelihood (default) \"ML\" - Maximum Likelihood bounds Numeric vector length 2 specifying bounds variance component optimization. Defaults c(1e-9, 1e9). SE Logical, whether compute return standard errors. Defaults FALSE. return_Hinv Logical, whether return inverse H matrix. Defaults FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mixed Model Solver — mixed_solve","text":"list containing: Vu Estimated variance component random effects. Ve Estimated variance component residuals. beta Estimated fixed effects coefficients. u Estimated random effects coefficients. LL Log-likelihood model. beta.SE Standard errors fixed effects coefficients (SE = TRUE). u.SE Standard errors random effects coefficients (SE = TRUE). Hinv Inverse H matrix (return_Hinv = TRUE).","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mixed Model Solver — mixed_solve","text":"function fits mixed model: Y = X*beta + Z*u + error, u ~ N(0, Vu*K) error ~ N(0, Ve*). variance components Vu Ve estimated using REML ML.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mixed Model Solver — mixed_solve","text":"","code":"if (FALSE) { # \\dontrun{ # Example with random data set.seed(123) n <- 100 Y <- rnorm(n) Z <- matrix(rnorm(n * 5), n, 5) K <- diag(5) X <- matrix(1, n, 1)  # Fit mixed model result <- mixed_solve(Y, X, Z, K) } # }"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve_optimized.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized Mixed Model Solver — mixed_solve_optimized","title":"Optimized Mixed Model Solver — mixed_solve_optimized","text":"optimized implementation mixed model estimation precomputes expensive matrix operations can reused across multiple voxels significant performance improvements.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve_optimized.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized Mixed Model Solver — mixed_solve_optimized","text":"","code":"mixed_solve_optimized(   X,   Z,   Y,   K = NULL,   workspace = NULL,   compute_se = FALSE,   n_threads = 0 )"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve_optimized.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized Mixed Model Solver — mixed_solve_optimized","text":"X Fixed effects design matrix (n × p) Z Random effects design matrix (n × q) Y Response data - can vector (single voxel) matrix (n × V multiple voxels) K Kinship/covariance matrix random effects (q × q). Defaults identity. workspace Precomputed workspace (optional, compute NULL) compute_se Whether compute standard errors (default: FALSE) n_threads Number OpenMP threads multi-voxel (0 = auto)","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/mixed_solve_optimized.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized Mixed Model Solver — mixed_solve_optimized","text":"List estimated parameters variance components","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Out Confound Variables — project_confounds","title":"Project Out Confound Variables — project_confounds","text":"Computes orthogonal projection matrix Q = - X(X'X)^(-1)X' projects space spanned confound regressors X. useful advanced users want cache reuse projection matrices.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Out Confound Variables — project_confounds","text":"","code":"project_confounds(X)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Out Confound Variables — project_confounds","text":"X Confound design matrix (n x p) n number timepoints p number confound regressors","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Out Confound Variables — project_confounds","text":"Projection matrix Q (n x n) projects column space X","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project Out Confound Variables — project_confounds","text":"function uses QR decomposition numerical stability instead computing Moore-Penrose pseudoinverse directly. resulting matrix Q can applied data remove influence confound regressors.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project Out Confound Variables — project_confounds","text":"","code":"if (FALSE) { # \\dontrun{ # Create confound matrix (intercept + linear trend) n <- 100 X_confounds <- cbind(1, 1:n)  # Get projection matrix Q <- project_confounds(X_confounds)  # Apply to data to remove confounds Y_clean <- Q %*% Y_raw } # }"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Out Confounds Using C++ — project_confounds_cpp","title":"Project Out Confounds Using C++ — project_confounds_cpp","text":"Fast C++ implementation projecting confound variables data trial design matrices. uses Cholesky decomposition numerical stability avoids creating large projection matrices.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Out Confounds Using C++ — project_confounds_cpp","text":"","code":"project_confounds_cpp(X_confounds, Y_data, C_trials)"},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Out Confounds Using C++ — project_confounds_cpp","text":"X_confounds Confound design matrix (n x k) Y_data Data matrix (n x V) V number voxels C_trials Trial design matrix (n x T) T number trials","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Out Confounds Using C++ — project_confounds_cpp","text":"List projected data (residual_data) projected trials (Q_dmat_ran)","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds_cpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project Out Confounds Using C++ — project_confounds_cpp","text":"function computes residuals Y - X(X'X)^(-1)X'Y C - X(X'X)^(-1)X'C without explicitly forming projection matrix Q = - X(X'X)^(-1)X'. approach uses ~100x less memory large n numerically stable.","code":""},{"path":"https://bbuchsbaum.github.io/fmrilss/reference/project_confounds_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project Out Confounds Using C++ — project_confounds_cpp","text":"","code":"if (FALSE) { # \\dontrun{ n <- 200; k <- 5; V <- 1000; T <- 50 X_confounds <- cbind(1, 1:n, rnorm(n*3))  # intercept + trend + noise Y_data <- matrix(rnorm(n*V), n, V) C_trials <- matrix(rnorm(n*T), n, T)  result <- project_confounds_cpp(X_confounds, Y_data, C_trials) } # }"}]
