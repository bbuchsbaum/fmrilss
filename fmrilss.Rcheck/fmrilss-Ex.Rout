
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "fmrilss"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('fmrilss')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("lss")
> ### * lss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lss
> ### Title: Least Squares Separate (LSS) Analysis
> ### Aliases: lss
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create example design matrices
> ##D n_timepoints <- 100
> ##D n_trials <- 20
> ##D n_voxels <- 1000
> ##D 
> ##D # Base design (intercept + linear trend)
> ##D dmat_base <- cbind(1, 1:n_timepoints)
> ##D 
> ##D # Trial design matrix (one column per trial)
> ##D dmat_ran <- matrix(0, n_timepoints, n_trials)
> ##D for(i in 1:n_trials) {
> ##D   trial_onset <- sample(1:(n_timepoints-10), 1)
> ##D   dmat_ran[trial_onset:(trial_onset+5), i] <- 1
> ##D }
> ##D 
> ##D # Create design list
> ##D bdes <- list(
> ##D   dmat_base = dmat_base,
> ##D   dmat_ran = dmat_ran,
> ##D   fixed_ind = NULL
> ##D )
> ##D 
> ##D # Simulate data
> ##D Y <- matrix(rnorm(n_timepoints * n_voxels), n_timepoints, n_voxels)
> ##D 
> ##D # Run LSS analysis
> ##D beta_estimates <- lss(Y = Y, bdes = bdes)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lss_beta_cpp")
> ### * lss_beta_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lss_beta_cpp
> ### Title: Vectorized LSS Beta Computation Using C++
> ### Aliases: lss_beta_cpp
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # After projecting out confounds
> ##D result <- project_confounds_cpp(X_confounds, Y_data, C_trials)
> ##D betas <- lss_beta_cpp(result$Q_dmat_ran, result$residual_data)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lss_naive")
> ### * lss_naive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lss_naive
> ### Title: Naive Least Squares Separate (LSS) Analysis
> ### Aliases: lss_naive
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Using same setup as lss() examples
> ##D beta_estimates_naive <- lss_naive(Y = Y, bdes = bdes)
> ##D 
> ##D # Compare with optimized version
> ##D beta_estimates_fast <- lss(Y = Y, bdes = bdes)
> ##D max(abs(beta_estimates_naive - beta_estimates_fast))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("project_confounds")
> ### * project_confounds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: project_confounds
> ### Title: Project Out Confound Variables
> ### Aliases: project_confounds
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create confound matrix (intercept + linear trend)
> ##D n <- 100
> ##D X_confounds <- cbind(1, 1:n)
> ##D 
> ##D # Get projection matrix
> ##D Q <- project_confounds(X_confounds)
> ##D 
> ##D # Apply to data to remove confounds
> ##D Y_clean <- Q %*% Y_raw
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.061 0.006 0.068 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
