# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

compute_residuals_cpp <- function(X, Y, C) {
    .Call(`_fmrilss_compute_residuals_cpp`, X, Y, C)
}

lss_compute_cpp <- function(C, Y) {
    .Call(`_fmrilss_lss_compute_cpp`, C, Y)
}

project_confounds_cpp <- function(X_confounds, Y_data, C_trials) {
    .Call(`_fmrilss_project_confounds_cpp`, X_confounds, Y_data, C_trials)
}

lss_beta_cpp <- function(C_projected, Y_projected) {
    .Call(`_fmrilss_lss_beta_cpp`, C_projected, Y_projected)
}

#' Fused Single-Pass LSS Solver (C++)
#'
#' This function computes Least Squares-Separate (LSS) beta estimates using
#' a memory-efficient, single-pass algorithm. It fuses the projection and
#' estimation steps, processing voxels in parallel blocks to maximize cache
#' efficiency.
#'
#' @param X The nuisance regressor matrix (confounds).
#' @param Y The data matrix (e.g., fMRI data).
#' @param C The trial-wise design matrix.
#' @param block_size The number of voxels to process in each parallel block.
#' @return A matrix of LSS beta estimates.
#' @keywords internal
lss_fused_optim_cpp <- function(X, Y, C, block_size = 96L) {
    .Call(`_fmrilss_lss_fused_optim_cpp`, X, Y, C, block_size)
}

lss_engine_vox_hrf_cpp <- function(Y, coeffs, basis_convolved, Z) {
    .Call(`_fmrilss_lss_engine_vox_hrf_cpp`, Y, coeffs, basis_convolved, Z)
}

lss_engine_vox_hrf_arma <- function(Y, coeffs, basis_convolved, Z) {
    .Call(`_fmrilss_lss_engine_vox_hrf_arma`, Y, coeffs, basis_convolved, Z)
}

lss_engine_vox_hrf_omp <- function(Y, coeffs, basis_convolved, Z) {
    .Call(`_fmrilss_lss_engine_vox_hrf_omp`, Y, coeffs, basis_convolved, Z)
}

mixed_solve_internal <- function(y_in, Z_in = NULL, K_in = NULL, X_in = NULL, method = "REML", bounds = as.numeric( c(1e-9, 1e9)), SE = FALSE, return_Hinv = FALSE) {
    .Call(`_fmrilss_mixed_solve_internal`, y_in, Z_in, K_in, X_in, method, bounds, SE, return_Hinv)
}

#' Mixed Model Workspace for Optimized Computation
#' 
#' Stores precomputed matrices and decompositions that can be reused
#' across multiple voxels to avoid repeated expensive computations.
#' 
#' @name MixedWorkspace
NULL

#' Fast analytical REML estimation for single variance component
#' 
#' For a single variance component model, the REML estimate of \eqn{\lambda = \sigma_e^2/\sigma_u^2}
#' has a closed-form solution that can be computed efficiently.
#' 
#' @param omega Transformed response vector Q'y
#' @param theta Transformed eigenvalues 
#' @param tol Convergence tolerance for Newton iterations
#' @param max_iter Maximum Newton iterations
#' @return Estimated variance ratio \eqn{\lambda}
#' @name fast_reml_lambda
NULL

#' Convert R list back to MixedWorkspace
#' @name list_to_workspace
NULL

#' Precompute workspace for mixed model optimization
#' 
#' Performs all the expensive computations that don't depend on the response
#' vector y, so they can be reused across multiple voxels.
#' 
#' @param X Fixed effects design matrix (n × p)
#' @param Z Random effects design matrix (n × q) 
#' @param K Kinship/covariance matrix for random effects (q × q)
#' @return MixedWorkspace object containing precomputed matrices
mixed_precompute_workspace <- function(X, Z, K) {
    .Call(`_fmrilss_mixed_precompute_workspace`, X, Z, K)
}

#' Fast single-voxel mixed model estimation using precomputed workspace
#' 
#' @param y Response vector for single voxel
#' @param ws_list Precomputed workspace (as R list)
#' @param compute_se Whether to compute standard errors
#' @return List with beta, u, Vu, Ve, and optionally standard errors
mixed_single_voxel_cpp <- function(y, ws_list, compute_se = FALSE) {
    .Call(`_fmrilss_mixed_single_voxel_cpp`, y, ws_list, compute_se)
}

#' Optimized multi-voxel mixed model estimation
#' 
#' Uses precomputed workspace and parallel processing to efficiently
#' estimate mixed models across many voxels.
#' 
#' @param Y Response matrix (n × V) where V is number of voxels
#' @param ws_list Precomputed workspace (as R list)
#' @param compute_se Whether to compute standard errors
#' @param n_threads Number of OpenMP threads (0 = auto)
#' @return List with matrices of estimates across voxels
mixed_multi_voxel_cpp <- function(Y, ws_list, compute_se = FALSE, n_threads = 0L) {
    .Call(`_fmrilss_mixed_multi_voxel_cpp`, Y, ws_list, compute_se, n_threads)
}

oasis_precompute_design <- function(X_trials, N_nuis) {
    .Call(`_fmrilss_oasis_precompute_design`, X_trials, N_nuis)
}

oasis_AtY_SY_blocked <- function(A, s_all, Q, Y, block_cols = 4096L) {
    .Call(`_fmrilss_oasis_AtY_SY_blocked`, A, s_all, Q, Y, block_cols)
}

oasis_betas_closed_form <- function(N_Y, S_Y, d, alpha, s, ridge_x = 0.0, ridge_b = 0.0, denom_eps = 1e-12) {
    .Call(`_fmrilss_oasis_betas_closed_form`, N_Y, S_Y, d, alpha, s, ridge_x, ridge_b, denom_eps)
}

oasis_betas_gammas <- function(N_Y, S_Y, d, alpha, s, ridge_x = 0.0, ridge_b = 0.0, denom_eps = 1e-12) {
    .Call(`_fmrilss_oasis_betas_gammas`, N_Y, S_Y, d, alpha, s, ridge_x, ridge_b, denom_eps)
}

oasisk_precompute_design <- function(X_trials, N_nuis, K) {
    .Call(`_fmrilss_oasisk_precompute_design`, X_trials, N_nuis, K)
}

oasisk_products <- function(A, S, Q, Y, block_cols = 4096L) {
    .Call(`_fmrilss_oasisk_products`, A, S, Q, Y, block_cols)
}

oasisk_betas <- function(D, C, E, N1, SY, ridge_x = 0.0, ridge_b = 0.0, diag_eps = 1e-10) {
    .Call(`_fmrilss_oasisk_betas`, D, C, E, N1, SY, ridge_x, ridge_b, diag_eps)
}

oasisk_compute_RY_norm2 <- function(Q, Y) {
    .Call(`_fmrilss_oasisk_compute_RY_norm2`, Q, Y)
}

oasisk_betas_se <- function(D, C, E, N1, SY, RY_norm2, ridge_x = 0.0, ridge_b = 0.0) {
    .Call(`_fmrilss_oasisk_betas_se`, D, C, E, N1, SY, RY_norm2, ridge_x, ridge_b)
}

estimate_hrf_cpp <- function(X, Y) {
    .Call(`_fmrilss_estimate_hrf_cpp`, X, Y)
}

lss_engine_vox_hrf <- function(Y, coeffs, basis_kernels, onset_idx, durations, nuisance, betas_ptr, progress, chunk_size, verbose) {
    invisible(.Call(`_fmrilss_lss_engine_vox_hrf`, Y, coeffs, basis_kernels, onset_idx, durations, nuisance, betas_ptr, progress, chunk_size, verbose))
}

