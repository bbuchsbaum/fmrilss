# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

compute_residuals_cpp <- function(X, Y, C) {
    .Call(`_fmrilss_compute_residuals_cpp`, X, Y, C)
}

lss_compute_cpp <- function(C, Y) {
    .Call(`_fmrilss_lss_compute_cpp`, C, Y)
}

project_confounds_cpp <- function(X_confounds, Y_data, C_trials) {
    .Call(`_fmrilss_project_confounds_cpp`, X_confounds, Y_data, C_trials)
}

lss_beta_cpp <- function(C_projected, Y_projected) {
    .Call(`_fmrilss_lss_beta_cpp`, C_projected, Y_projected)
}

#' Fused Single-Pass LSS Solver (C++)
#'
#' This function computes Least Squares-Separate (LSS) beta estimates using
#' a memory-efficient, single-pass algorithm. It fuses the projection and
#' estimation steps, processing voxels in parallel blocks to maximize cache
#' efficiency.
#'
#' @param X The nuisance regressor matrix (confounds).
#' @param Y The data matrix (e.g., fMRI data).
#' @param C The trial-wise design matrix.
#' @param block_size The number of voxels to process in each parallel block.
#' @return A matrix of LSS beta estimates.
#' @keywords internal
lss_fused_optim_cpp <- function(X, Y, C, block_size = 96L) {
    .Call(`_fmrilss_lss_fused_optim_cpp`, X, Y, C, block_size)
}

mixed_solve_internal <- function(y_in, Z_in = NULL, K_in = NULL, X_in = NULL, method = "REML", bounds = as.numeric( c(1e-9, 1e9)), SE = FALSE, return_Hinv = FALSE) {
    .Call(`_fmrilss_mixed_solve_internal`, y_in, Z_in, K_in, X_in, method, bounds, SE, return_Hinv)
}

