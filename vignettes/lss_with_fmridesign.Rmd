---
title: Using fmridesign with fmrilss
author: LSS Package Authors
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: '%\VignetteIndexEntry{Using fmridesign with fmrilss} %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}'
params:
  family: red
css: albers.css
resource_files:
- albers.css
- albers.js
includes:
  in_header: |-
    <script src="albers.js"></script>
    <script>document.addEventListener('DOMContentLoaded',function(){document.body.classList.add('palette-red');});</script>

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("albersdown", quietly = TRUE)) ggplot2::theme_set(albersdown::theme_albers(params$family))
library(fmrilss)
library(fmridesign)
library(fmrihrf)
```

## Introduction

The `fmridesign` package provides a powerful formula-based interface for creating fMRI design matrices. While `fmrilss` has its own `design_spec` format for the OASIS method, you can now use `event_model` and `baseline_model` objects directly with the new `lss_design()` function.

### When to Use lss_design()

Use `lss_design()` when:

- You have **multi-condition factorial designs**
- You need **parametric modulators** (e.g., RT, difficulty ratings)
- You want **design validation** and diagnostic tools
- You prefer **formula-based specification**
- You need **explicit multi-run handling** with run-relative onsets

### When to Use Traditional lss()

Use the traditional `lss()` interface when:

- You have simple **trial-wise designs** already constructed
- You want **minimal dependencies**
- You're using **internal SBHM pipelines**
- You already have design matrices prepared

## Quick Start

Here's a minimal example using `lss_design()`:

```{r quickstart, eval=FALSE}
# 1. Define temporal structure (single run, 100 scans, TR=2s)
sframe <- sampling_frame(blocklens = 100, TR = 2)

# 2. Create trial data
trials <- data.frame(
  onset = seq(10, 90, by = 20),  # Events every 20 seconds
  run = 1
)

# 3. Build event model with trialwise design
emod <- event_model(
  onset ~ trialwise(basis = "spmg1"),
  data = trials,
  block = ~run,
  sampling_frame = sframe
)

# 4. Run LSS
Y <- matrix(rnorm(100 * 1000), 100, 1000)  # Simulated data
beta <- lss_design(Y, emod, method = "oasis")

# Result: 5 trials × 1000 voxels
dim(beta)
```

## Multi-Run Experiments

One of the key advantages of `lss_design()` is automatic handling of multi-run experiments with proper onset timing.

### Onset Convention: Run-Relative

**Important:** When using `fmridesign`, onsets should be **run-relative** (resetting to 0 at the start of each run). This is the standard convention for multi-run fMRI experiments.

```{r multirun, eval=FALSE}
# Define 2 runs with 150 scans each
sframe <- sampling_frame(blocklens = c(150, 150), TR = 2)

# Trial data with run-relative onsets
trials <- data.frame(
  onset = c(10, 30, 50, 70, 90, 110,   # Run 1: onsets relative to run start
            10, 30, 50, 70, 90, 110),   # Run 2: onsets relative to run start
  run = rep(1:2, each = 6)
)

# Create event model - conversion to global time is automatic
emod <- event_model(
  onset ~ trialwise(basis = "spmg1"),
  data = trials,
  block = ~run,
  sampling_frame = sframe
)

# Simulate data for both runs
Y <- matrix(rnorm(300 * 1000), 300, 1000)

# Run LSS
beta <- lss_design(Y, emod, method = "oasis")

# Result: 12 trials × 1000 voxels
dim(beta)
```

### Why Run-Relative Onsets?

- **Standard convention**: Most experiment software (E-Prime, PsychoPy) logs onsets relative to run start
- **Easier data management**: No manual offset calculations needed
- **Automatic conversion**: `fmridesign` handles conversion to global time internally
- **Less error-prone**: Reduces risk of incorrect timing specifications

## Adding Baseline Correction

The `baseline_model` allows you to specify drift correction, block intercepts, and nuisance regressors in a structured way.

```{r baseline, eval=FALSE}
# Same setup as before
sframe <- sampling_frame(blocklens = c(150, 150), TR = 2)
trials <- data.frame(
  onset = c(10, 30, 50, 70, 90, 110,
            10, 30, 50, 70, 90, 110),
  run = rep(1:2, each = 6)
)

emod <- event_model(
  onset ~ trialwise(basis = "spmg1"),
  data = trials,
  block = ~run,
  sampling_frame = sframe
)

# Create baseline model with B-spline drift correction
bmodel <- baseline_model(
  basis = "bs",          # B-spline basis
  degree = 5,            # 5 basis functions per run
  sframe = sframe,
  intercept = "runwise"  # Separate intercept per run
)

Y <- matrix(rnorm(300 * 1000), 300, 1000)

# LSS with baseline correction
beta <- lss_design(Y, emod, bmodel, method = "oasis")
```

### Adding Motion Parameters

```{r motion, eval=FALSE}
# Load motion parameters (one file per run)
motion_run1 <- as.matrix(read.table("motion_run1.txt"))  # 150 × 6
motion_run2 <- as.matrix(read.table("motion_run2.txt"))  # 150 × 6

# Create baseline model with motion as nuisance
bmodel <- baseline_model(
  basis = "bs",
  degree = 5,
  sframe = sframe,
  intercept = "runwise",
  nuisance_list = list(motion_run1, motion_run2)
)

beta <- lss_design(Y, emod, bmodel, method = "oasis")
```

## Multi-Basis HRFs

For multi-basis HRF models (e.g., canonical + temporal + dispersion derivatives), use `nbasis`:

```{r multibasis, eval=FALSE}
# Create event model with SPMG3 (3 basis functions)
emod <- event_model(
  onset ~ trialwise(basis = "spmg3", nbasis = 3),
  data = trials,
  block = ~run,
  sampling_frame = sframe
)

Y <- matrix(rnorm(300 * 1000), 300, 1000)

# LSS will auto-detect K = 3
beta <- lss_design(Y, emod, method = "oasis")

# Output: (12 trials × 3 basis) × 1000 voxels = 36 × 1000
dim(beta)

# Extract canonical basis estimates (every 3rd row starting at 1)
beta_canonical <- beta[seq(1, nrow(beta), by = 3), ]
dim(beta_canonical)  # 12 × 1000
```

## Ridge Regularization

For designs with potential collinearity, use ridge regularization:

```{r ridge, eval=FALSE}
beta <- lss_design(
  Y, emod, bmodel,
  method = "oasis",
  oasis = list(
    ridge_mode = "fractional",
    ridge_x = 0.02,    # Ridge for trial regressors
    ridge_b = 0.02     # Ridge for baseline regressors
  )
)
```

## Comparison with design_spec

### Using design_spec (old approach)

```{r designspec, eval=FALSE}
# Manual design_spec construction
beta_old <- lss(
  Y,
  method = "oasis",
  oasis = list(
    design_spec = list(
      sframe = sframe,
      cond = list(
        onsets = c(10, 30, 50, ..., 280, 300),  # GLOBAL onsets required!
        hrf = HRF_SPMG1,
        span = 30
      )
    )
  )
)
```

**Limitations:**
- Requires **global/absolute onsets** (not run-relative)
- No structured baseline handling
- No multi-condition support
- No parametric modulators
- Less validation

### Using lss_design() (new approach)

```{r lssdesign, eval=FALSE}
# Formula-based design
emod <- event_model(
  onset ~ trialwise(basis = "spmg1"),
  data = trials,  # Run-relative onsets
  block = ~run,
  sampling_frame = sframe
)

bmodel <- baseline_model(basis = "bs", degree = 5, sframe = sframe)

beta_new <- lss_design(Y, emod, bmodel, method = "oasis")
```

**Advantages:**
- **Run-relative onsets** (standard convention)
- **Structured baseline** (drift + nuisance)
- **Automatic validation**
- **Richer metadata**
- **Formula-based DSL**

## Advanced: Parametric Modulators

`event_model` supports parametric modulators for trial-by-trial amplitude modulation:

```{r parametric, eval=FALSE}
# Trial data with reaction times
trials <- data.frame(
  onset = c(10, 30, 50, 70, 90, 110),
  RT = c(0.5, 0.7, 0.6, 0.8, 0.5, 0.9),
  run = 1
)

# Center RT
trials$RT_c <- scale(trials$RT, center = TRUE, scale = FALSE)[, 1]

# Model: trial effects + RT modulation
emod <- event_model(
  onset ~ trialwise() + hrf(RT_c),
  data = trials,
  block = ~run,
  sampling_frame = sframe
)

# Note: This creates trial-wise regressors PLUS an RT amplitude modulator
# May require special handling in OASIS for proper separation
```

## Troubleshooting

### Error: "Y has X rows but sampling_frame expects Y scans"

**Cause:** Mismatch between data dimensions and sampling_frame specification.

**Solution:** Check that `sum(blocklens)` matches `nrow(Y)`:

```{r troubleshoot1, eval=FALSE}
sframe <- sampling_frame(blocklens = c(150, 150), TR = 2)
sum(fmrihrf::blocklens(sframe))  # Should equal nrow(Y)
```

### Error: "event_model and baseline_model have different sampling_frames"

**Cause:** The two models were created with different `sampling_frame` objects.

**Solution:** Use the same `sframe` object for both:

```{r troubleshoot2, eval=FALSE}
sframe <- sampling_frame(blocklens = c(150, 150), TR = 2)

emod <- event_model(..., sampling_frame = sframe)
bmodel <- baseline_model(..., sframe = sframe)
```

### Warning: "High collinearity detected"

**Cause:** Events are too close together or design is ill-conditioned.

**Solution:** Use ridge regularization:

```{r troubleshoot3, eval=FALSE}
beta <- lss_design(
  Y, emod, bmodel,
  oasis = list(ridge_mode = "fractional", ridge_x = 0.02)
)
```

## Summary

The `lss_design()` function provides a modern, formula-based interface for LSS analysis that:

- Handles **multi-run experiments** correctly with run-relative onsets
- Provides **structured baseline** specification
- Supports **multi-basis HRFs** with automatic detection
- Validates **design compatibility** automatically
- Integrates with the **fmridesign ecosystem**

For simple designs or when you already have design matrices prepared, the traditional `lss()` interface remains fully supported and unchanged.

## Further Reading

- `vignette("fmrilss")` - Traditional LSS interface
- `vignette("oasis_method", package = "fmrilss")` - OASIS method details
- `vignette("a_04_event_models", package = "fmridesign")` - Event model tutorial
- `vignette("a_03_baseline_model", package = "fmridesign")` - Baseline model tutorial
