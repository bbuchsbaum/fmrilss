<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>OASIS Theory: Algebra and Implementation Details • fmrilss</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="OASIS Theory: Algebra and Implementation Details">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">fmrilss</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/getting_started.html">Getting Started with fmrilss</a></li>
    <li><a class="dropdown-item" href="../articles/oasis_method.html">The OASIS Method: Optimized Analytic Single-pass Inverse Solution</a></li>
    <li><a class="dropdown-item" href="../articles/oasis_theory.html">OASIS Theory: Algebra and Implementation Details</a></li>
    <li><a class="dropdown-item" href="../articles/voxel-wise-hrf.html">Voxel-wise HRF Modeling with fmrilss</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>OASIS Theory: Algebra and Implementation Details</h1>
                        <h4 data-toc-skip class="author">fmrilss
Development Team</h4>
            
            <h4 data-toc-skip class="date">2025-09-24</h4>
      

      <div class="d-none name"><code>oasis_theory.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="motivation">Motivation<a class="anchor" aria-label="anchor" href="#motivation"></a>
</h2>
<p>Optimized Analytic Single-pass Inverse Solution (OASIS) extends Least
Squares Separate (LSS) estimation through algebraic reformulation that
enables single-pass computation of all trial estimates. This document
provides the mathematical foundation and implementation details.</p>
<div class="section level3">
<h3 id="computational-intuition">Computational Intuition<a class="anchor" aria-label="anchor" href="#computational-intuition"></a>
</h3>
<p>Standard LSS requires N separate GLM fits for N trials, each
involving: 1. Matrix assembly: O(T²) operations 2. QR decomposition:
O(T³) operations 3. Back-substitution: O(T²) operations</p>
<p>Total complexity: O(NT³) for N trials</p>
<p>OASIS recognizes that these N models share substantial structure. By
factoring out common computations, OASIS reduces complexity to: 1.
Single QR decomposition: O(T³) 2. Shared projections: O(NT²) 3.
Per-trial solutions: O(N)</p>
<p>Total complexity: O(T³ + NT²), a significant reduction when N is
large.</p>
</div>
<div class="section level3">
<h3 id="visual-comparison-of-computational-scaling">Visual Comparison of Computational Scaling<a class="anchor" aria-label="anchor" href="#visual-comparison-of-computational-scaling"></a>
</h3>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Demonstrate computational scaling</span></span>
<span><span class="va">N_trials</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">50</span>, <span class="fl">100</span>, <span class="fl">200</span>, <span class="fl">500</span>, <span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">T_points</span> <span class="op">&lt;-</span> <span class="fl">200</span>  <span class="co"># Fixed number of timepoints</span></span>
<span></span>
<span><span class="co"># Simplified complexity models (arbitrary units)</span></span>
<span><span class="va">classical_ops</span> <span class="op">&lt;-</span> <span class="va">N_trials</span> <span class="op">*</span> <span class="va">T_points</span><span class="op">^</span><span class="fl">3</span> <span class="op">/</span> <span class="fl">1e6</span>  <span class="co"># O(NT³)</span></span>
<span><span class="va">oasis_ops</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">T_points</span><span class="op">^</span><span class="fl">3</span> <span class="op">+</span> <span class="va">N_trials</span> <span class="op">*</span> <span class="va">T_points</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">/</span> <span class="fl">1e6</span>  <span class="co"># O(T³ + NT²)</span></span>
<span></span>
<span><span class="co"># Create comparison plot</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">N_trials</span>, <span class="va">classical_ops</span>, type<span class="op">=</span><span class="st">'l'</span>, col<span class="op">=</span><span class="st">'red'</span>, lwd<span class="op">=</span><span class="fl">2</span>,</span>
<span>     xlab<span class="op">=</span><span class="st">'Number of Trials'</span>, ylab<span class="op">=</span><span class="st">'Computational Operations (millions)'</span>,</span>
<span>     main<span class="op">=</span><span class="st">'Computational Complexity: Classical LSS vs OASIS'</span>,</span>
<span>     ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">classical_ops</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">N_trials</span>, <span class="va">oasis_ops</span>, col<span class="op">=</span><span class="st">'blue'</span>, lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">'topleft'</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'Classical LSS'</span>, <span class="st">'OASIS'</span><span class="op">)</span>,</span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'red'</span>, <span class="st">'blue'</span><span class="op">)</span>, lwd<span class="op">=</span><span class="fl">2</span>, bty<span class="op">=</span><span class="st">'n'</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add shaded region showing computational savings</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/polygon.html" class="external-link">polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">N_trials</span>, <span class="fu"><a href="https://rdrr.io/r/base/rev.html" class="external-link">rev</a></span><span class="op">(</span><span class="va">N_trials</span><span class="op">)</span><span class="op">)</span>,</span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">classical_ops</span>, <span class="fu"><a href="https://rdrr.io/r/base/rev.html" class="external-link">rev</a></span><span class="op">(</span><span class="va">oasis_ops</span><span class="op">)</span><span class="op">)</span>,</span>
<span>        col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html" class="external-link">rgb</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.8</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span><span class="op">)</span>, border<span class="op">=</span><span class="cn">NA</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html" class="external-link">text</a></span><span class="op">(</span><span class="fl">500</span>, <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">classical_ops</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span>, <span class="va">oasis_ops</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,</span>
<span>     <span class="st">'Computational\nSavings'</span>, col<span class="op">=</span><span class="st">'darkgreen'</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="oasis_theory_files/figure-html/complexity-comparison-1.png" alt="Computational complexity: Classical LSS vs OASIS" width="768"><p class="caption">
Computational complexity: Classical LSS vs OASIS
</p>
</div>
</div>
<div class="section level3">
<h3 id="prerequisites">Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites"></a>
</h3>
<p>This vignette assumes familiarity with: - QR decomposition and
orthogonal projection matrices - Ridge regression and regularization -
Matrix calculus and linear algebra - The standard LSS formulation</p>
<p>Code references point to <code>R/oasis_glue.R</code> and
<code>src/oasis_core.cpp</code> implementations.</p>
<p>Notation used throughout:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>T</mi><mo>×</mo><mi>V</mi></mrow></msup></mrow><annotation encoding="application/x-tex">Y \in \mathbb{R}^{T \times V}</annotation></semantics></math>:
voxel data
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
time points,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
voxels)</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>N</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>T</mi><mo>×</mo><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X = [x_1, \dots, x_N] \in \mathbb{R}^{T \times N}</annotation></semantics></math>:
trial regressors for one condition</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>T</mi><mo>×</mo><msub><mi>K</mi><mi>z</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Z \in \mathbb{R}^{T \times K_z}</annotation></semantics></math>:
nuisance/experimental regressors shared across trials</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>I</mi><mo>−</mo><mi>Q</mi><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">R = I - QQ^T</annotation></semantics></math>:
orthogonal projector removing nuisance effects
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
comes from QR factorisation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>Z</mi><mo>,</mo><mtext mathvariant="normal">others</mtext><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[Z,\text{others}]</annotation></semantics></math>)</li>
<li>Inner products are denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msup><mi>a</mi><mi>T</mi></msup><mi>b</mi></mrow><annotation encoding="application/x-tex">\langle a, b \rangle = a^T b</annotation></semantics></math>
</li>
</ul>
<p>We first treat the single-basis case (one regressor per trial) before
generalizing to multi-basis HRFs.</p>
</div>
</div>
<div class="section level2">
<h2 id="classical-lss-recap">Classical LSS Recap<a class="anchor" aria-label="anchor" href="#classical-lss-recap"></a>
</h2>
<p>Classical LSS fits, for each trial
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>,
a GLM with design
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>x</mi><mi>j</mi></msub><mo>,</mo><msub><mi>b</mi><mi>j</mi></msub><mo>,</mo><mi>Z</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[x_j, b_j, Z]</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>≠</mo><mi>j</mi></mrow></msub><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_j = \sum_{i \neq j} x_i</annotation></semantics></math>.
Solving each model independently costs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(N)</annotation></semantics></math>
QR factorizations. Algebraically, the trial-specific beta can be
expressed as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>R</mi><msub><mi>x</mi><mi>j</mi></msub><mo>,</mo><mi>R</mi><mi>Y</mi><mo stretchy="false" form="postfix">⟩</mo><mo>−</mo><mfrac><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>R</mi><msub><mi>x</mi><mi>j</mi></msub><mo>,</mo><mi>R</mi><msub><mi>b</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><mrow><mo stretchy="false" form="postfix">∥</mo><mi>R</mi><msub><mi>b</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup></mrow></mfrac><mo stretchy="false" form="prefix">⟨</mo><mi>R</mi><msub><mi>b</mi><mi>j</mi></msub><mo>,</mo><mi>R</mi><mi>Y</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><mrow><mo stretchy="false" form="postfix">∥</mo><mi>R</mi><msub><mi>x</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup><mo>−</mo><mfrac><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>R</mi><msub><mi>x</mi><mi>j</mi></msub><mo>,</mo><mi>R</mi><msub><mi>b</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">⟩</mo><mn>2</mn></msup></mrow><mrow><mo stretchy="false" form="postfix">∥</mo><mi>R</mi><msub><mi>b</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup></mrow></mfrac></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\hat{\beta}_j = \frac{\langle Rx_j, RY \rangle - \frac{\langle Rx_j, Rb_j \rangle}{\|Rb_j\|^2} \langle Rb_j, RY \rangle}{\|Rx_j\|^2 - \frac{\langle Rx_j, Rb_j \rangle^2}{\|Rb_j\|^2}}.
</annotation></semantics></math></p>
<p>OASIS extracts and reuses the common computational components
(projections, norms, cross-products) across all trials, computing each
only once.</p>
</div>
<div class="section level2">
<h2 id="single-basis-oasis-algebra">Single-Basis OASIS Algebra<a class="anchor" aria-label="anchor" href="#single-basis-oasis-algebra"></a>
</h2>
<p>After residualising against nuisance regressors we define:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>=</mo><mi>R</mi><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j = Rx_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s = \sum_{j=1}^N a_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub><mo>=</mo><mo stretchy="false" form="postfix">∥</mo><msub><mi>a</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d_j = \|a_j\|^2</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>j</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>a</mi><mi>j</mi></msub><mo>,</mo><mi>s</mi><mo>−</mo><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\alpha_j = \langle a_j, s - a_j \rangle</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub><mo>=</mo><mo stretchy="false" form="postfix">∥</mo><mi>s</mi><mo>−</mo><msub><mi>a</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">s_j = \|s - a_j\|^2</annotation></semantics></math></li>
</ul>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>a</mi><mi>j</mi></msub><mo>,</mo><mi>R</mi><msub><mi>Y</mi><mrow><mo>⋅</mo><mi>v</mi></mrow></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">n_{jv} = \langle a_j, RY_{\cdot v} \rangle</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>v</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>s</mi><mo>,</mo><mi>R</mi><msub><mi>Y</mi><mrow><mo>⋅</mo><mi>v</mi></mrow></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">m_v = \langle s, RY_{\cdot v} \rangle</annotation></semantics></math>.
The pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>β</mi><mi>j</mi></msub><mo>,</mo><msub><mi>γ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta_j, \gamma_j)</annotation></semantics></math>
solving the 2×2 system for trial
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
and voxel
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
is obtained from</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>γ</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>m</mi><mi>v</mi></msub><mo>−</mo><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>G</mi><mi>j</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>d</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>x</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>α</mi><mi>j</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>α</mi><mi>j</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>s</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>b</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
G_j \begin{bmatrix} \beta_{jv} \\ \gamma_{jv} \end{bmatrix} = \begin{bmatrix} n_{jv} \\ m_v - n_{jv} \end{bmatrix},
\quad
G_j = \begin{bmatrix} d_j + \lambda_x &amp; \alpha_j \\ \alpha_j &amp; s_j + \lambda_b \end{bmatrix},
</annotation></semantics></math></p>
<p>with ridge penalties
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>x</mi></msub><mo>,</mo><msub><mi>λ</mi><mi>b</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_x, \lambda_b \ge 0</annotation></semantics></math>.
The inverse of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>j</mi></msub><annotation encoding="application/x-tex">G_j</annotation></semantics></math>
is analytic, so<br><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo>=</mo><mfrac><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo>−</mo><msub><mi>α</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>m</mi><mi>v</mi></msub><mo>−</mo><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>d</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>α</mi><mi>j</mi><mn>2</mn></msubsup></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\beta_{jv} = \frac{(s_j + \lambda_b) n_{jv} - \alpha_j (m_v - n_{jv})}{(d_j + \lambda_x)(s_j + \lambda_b) - \alpha_j^2}.
</annotation></semantics></math></p>
<p>This is exactly what <code>oasis_betas_closed_form()</code>
implements (C++ file <code>src/oasis_core.cpp</code>). The
precomputation step <code>oasis_precompute_design()</code> produces
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>,</mo><mi>s</mi><mo>,</mo><msub><mi>d</mi><mi>j</mi></msub><mo>,</mo><msub><mi>α</mi><mi>j</mi></msub><mo>,</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j, s, d_j, \alpha_j, s_j</annotation></semantics></math>
once, while <code>oasis_AtY_SY_blocked()</code> streams through voxels
to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><annotation encoding="application/x-tex">n_{jv}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mi>v</mi></msub><annotation encoding="application/x-tex">m_v</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="fractional-ridge">Fractional Ridge<a class="anchor" aria-label="anchor" href="#fractional-ridge"></a>
</h3>
<p><code>oasis$ridge_mode = "fractional"</code> sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>x</mi></msub><mo>=</mo><msub><mi>η</mi><mi>x</mi></msub><mo>⋅</mo><mover><mi>d</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\lambda_x = \eta_x \cdot \bar{d}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>b</mi></msub><mo>=</mo><msub><mi>η</mi><mi>b</mi></msub><mo>⋅</mo><mover><mi>s</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\lambda_b = \eta_b \cdot \bar{s}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>d</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{d}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>s</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{s}</annotation></semantics></math>
are means of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>j</mi></msub><annotation encoding="application/x-tex">d_j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>j</mi></msub><annotation encoding="application/x-tex">s_j</annotation></semantics></math>.
The helper <code>.oasis_resolve_ridge()</code> implements this scaling.
Absolute ridge uses the supplied values directly.</p>
</div>
<div class="section level3">
<h3 id="standard-errors">Standard Errors<a class="anchor" aria-label="anchor" href="#standard-errors"></a>
</h3>
<p>Given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>G</mi><mi>j</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><annotation encoding="application/x-tex">G_j^{-1}</annotation></semantics></math>
and residual norm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mi>R</mi><mi>Y</mi><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\|RY\|^2</annotation></semantics></math>,
the variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><annotation encoding="application/x-tex">\beta_{jv}</annotation></semantics></math>
is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Var</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>σ</mi><mrow><mi>j</mi><mi>v</mi></mrow><mn>2</mn></msubsup><msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>G</mi><mi>j</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mn>11</mn></msub><mo>,</mo><mspace width="1.0em"></mspace><msubsup><mi>σ</mi><mrow><mi>j</mi><mi>v</mi></mrow><mn>2</mn></msubsup><mo>=</mo><mfrac><msub><mtext mathvariant="normal">SSE</mtext><mrow><mi>j</mi><mi>v</mi></mrow></msub><mtext mathvariant="normal">dof</mtext></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
\operatorname{Var}(\hat{\beta}_{jv}) = \sigma_{jv}^2 \left( G_j^{-1} \right)_{11}, \quad \sigma_{jv}^2 = \frac{\text{SSE}_{jv}}{\text{dof}},
</annotation></semantics></math></p>
<p>with</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">SSE</mtext><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="postfix">∥</mo><mi>R</mi><msub><mi>Y</mi><mrow><mo>⋅</mo><mi>v</mi></mrow></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo>+</mo><msub><mi>γ</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>m</mi><mi>v</mi></msub><mo>−</mo><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>d</mi><mi>j</mi></msub><msubsup><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow><mn>2</mn></msubsup><mo>+</mo><msub><mi>s</mi><mi>j</mi></msub><msubsup><mi>γ</mi><mrow><mi>j</mi><mi>v</mi></mrow><mn>2</mn></msubsup><mo>+</mo><mn>2</mn><msub><mi>α</mi><mi>j</mi></msub><msub><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><msub><mi>γ</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SSE}_{jv} = \|RY_{\cdot v}\|^2 - 2 (\beta_{jv} n_{jv} + \gamma_{jv} (m_v - n_{jv})) + d_j \beta_{jv}^2 + s_j \gamma_{jv}^2 + 2 \alpha_j \beta_{jv} \gamma_{jv}.
</annotation></semantics></math></p>
<p><code>.oasis_se_from_norms()</code> realises this computation,
reusing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><annotation encoding="application/x-tex">n_{jv}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mi>v</mi></msub><annotation encoding="application/x-tex">m_v</annotation></semantics></math>
and the cached design scalars.</p>
</div>
</div>
<div class="section level2">
<h2 id="multi-basis-extension">Multi-Basis Extension<a class="anchor" aria-label="anchor" href="#multi-basis-extension"></a>
</h2>
<p>When the HRF contributes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">K &gt; 1</annotation></semantics></math>
basis functions, each trial has columns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>T</mi><mo>×</mo><mi>K</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A_j \in \mathbb{R}^{T \times K}</annotation></semantics></math>.
Define</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">S = \sum_j A_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>j</mi></msub><mo>=</mo><msubsup><mi>A</mi><mi>j</mi><mi>T</mi></msubsup><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D_j = A_j^T A_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub><mo>=</mo><msubsup><mi>A</mi><mi>j</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mo>−</mo><msub><mi>A</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_j = A_j^T (S - A_j)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>j</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mo>−</mo><msub><mi>A</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mo>−</mo><msub><mi>A</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">E_j = (S - A_j)^T (S - A_j)</annotation></semantics></math></li>
</ul>
<p>Per voxel we need
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mn>1</mn><mo>=</mo><msup><mi>A</mi><mi>T</mi></msup><mi>R</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">N1 = A^T RY</annotation></semantics></math>
(stacked
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
blocks of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>)
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>Y</mi><mo>=</mo><msup><mi>S</mi><mi>T</mi></msup><mi>R</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">SY = S^T RY</annotation></semantics></math>.
The block system is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>D</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>x</mi></msub><mi>I</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>C</mi><mi>j</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>C</mi><mi>j</mi><mi>T</mi></msubsup></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>E</mi><mi>j</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>b</mi></msub><mi>I</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>B</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>Γ</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>N</mi><msub><mn>1</mn><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>S</mi><msub><mi>Y</mi><mi>v</mi></msub><mo>−</mo><mi>N</mi><msub><mn>1</mn><mrow><mi>j</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
D_j + \lambda_x I &amp; C_j \\
C_j^T &amp; E_j + \lambda_b I
\end{bmatrix}
\begin{bmatrix}
B_{jv} \\
\Gamma_{jv}
\end{bmatrix}
=
\begin{bmatrix}
N1_{jv} \\
SY_v - N1_{jv}
\end{bmatrix},
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">B_{jv} \in \mathbb{R}^K</annotation></semantics></math>.
<code>oasisk_betas()</code> solves this 2K×2K system via Cholesky
factorisation. Ridge again adds
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>x</mi></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">\lambda_x I</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>b</mi></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">\lambda_b I</annotation></semantics></math>
to the block diagonals. Compared to the single-basis path, only the
shapes of the cached matrices differ; the solve is still analytic per
trial/voxel block.</p>
<p>The companion <code>oasisk_betas_se()</code> extends the SSE/variance
calculation to the multi-basis case, using the same building blocks.</p>
</div>
<div class="section level2">
<h2 id="hrf-aware-design-construction">HRF-Aware Design Construction<a class="anchor" aria-label="anchor" href="#hrf-aware-design-construction"></a>
</h2>
<p>OASIS can construct
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
on the fly from event specifications.
<code>.oasis_build_X_from_events()</code> uses
<code><a href="https://bbuchsbaum.github.io/fmrihrf/reference/regressor_set.html" class="external-link">fmrihrf::regressor_set()</a></code> to generate trial-wise columns
(and optional other-condition aggregates) given:</p>
<ul>
<li>
<code>cond$onsets</code>: per-trial onset times</li>
<li>
<code>cond$hrf</code>: HRF object (canonical, FIR, multi-basis,
user-defined)</li>
<li>
<code>cond$span</code>, <code>precision</code>, <code>method</code>:
convolution controls</li>
</ul>
<p>This design is then residualised against nuisance regressors and fed
into the algebra above. Because the HRF definition enters directly,
switching HRFs or running grid searches automatically regenerates a
matching design. When you provide an explicit <code>X</code>, OASIS
skips this step and assumes you have already encoded the HRF in the
matrix.</p>
</div>
<div class="section level2">
<h2 id="ar1-whitening">AR(1) Whitening<a class="anchor" aria-label="anchor" href="#ar1-whitening"></a>
</h2>
<p><code>oasis$whiten = "ar1"</code> estimates a common AR(1)
coefficient from residualised data. <code>.oasis_ar1_whitener()</code>
computes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
and applies Toeplitz-safe differencing:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>y</mi><mo accent="true">̃</mo></mover><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msqrt><mrow><mn>1</mn><mo>−</mo><msup><mi>ρ</mi><mn>2</mn></msup></mrow></msqrt><msub><mi>y</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>y</mi><mi>t</mi></msub><mo>−</mo><mi>ρ</mi><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mi>t</mi><mo>&gt;</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\tilde{y}_t = \begin{cases}
\sqrt{1 - \rho^2} y_1 &amp; t = 1, \\
y_t - \rho y_{t-1} &amp; t &gt; 1.
\end{cases}
</annotation></semantics></math></p>
<p>The same transformation is applied to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and nuisance regressors before the standard OASIS algebra runs.
Whitening preserves the single-pass benefits because the transformed
data are treated exactly like the original inputs.</p>
</div>
<div class="section level2">
<h2 id="diagnostics-output">Diagnostics Output<a class="anchor" aria-label="anchor" href="#diagnostics-output"></a>
</h2>
<p>When <code>oasis$return_diag = TRUE</code>, OASIS returns the
precomputed design scalars:</p>
<ul>
<li>Single-basis:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub><mo>,</mo><msub><mi>α</mi><mi>j</mi></msub><mo>,</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j, \alpha_j, s_j</annotation></semantics></math>
(from <code>oasis_precompute_design()</code>)</li>
<li>Multi-basis:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>j</mi></msub><mo>,</mo><msub><mi>C</mi><mi>j</mi></msub><mo>,</mo><msub><mi>E</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D_j, C_j, E_j</annotation></semantics></math>
(from <code>oasisk_precompute_design()</code>)</li>
</ul>
<p>These matrices are useful for checking trial collinearity, energy,
and the effect of ridge scaling.</p>
</div>
<div class="section level2">
<h2 id="algorithm-summary">Algorithm Summary<a class="anchor" aria-label="anchor" href="#algorithm-summary"></a>
</h2>
<p>Putting everything together, the single-basis solver proceeds as
follows:</p>
<ol style="list-style-type: decimal">
<li>Residualise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
against nuisance regressors, optionally with whitening.</li>
<li>Compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>,</mo><mi>s</mi><mo>,</mo><msub><mi>d</mi><mi>j</mi></msub><mo>,</mo><msub><mi>α</mi><mi>j</mi></msub><mo>,</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j, s, d_j, \alpha_j, s_j</annotation></semantics></math>
(<code>oasis_precompute_design</code>).</li>
<li>Stream through voxels in blocks, forming
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>Y</mi></msub><mo>=</mo><msup><mi>A</mi><mi>T</mi></msup><mi>R</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">N_Y = A^T RY</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>Y</mi></msub><mo>=</mo><msup><mi>s</mi><mi>T</mi></msup><mi>R</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">S_Y = s^T RY</annotation></semantics></math>
(<code>oasis_AtY_SY_blocked</code>).</li>
<li>Apply ridge scaling (absolute or fractional) to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>x</mi></msub><mo>,</mo><msub><mi>λ</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_x, \lambda_b</annotation></semantics></math>.</li>
<li>For each trial, evaluate the closed-form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><annotation encoding="application/x-tex">\beta_{jv}</annotation></semantics></math>
(and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>γ</mi><mrow><mi>j</mi><mi>v</mi></mrow></msub><annotation encoding="application/x-tex">\gamma_{jv}</annotation></semantics></math>
if SEs requested).</li>
<li>Optionally compute SEs and diagnostics.</li>
</ol>
<p>The multi-basis path swaps steps 2–5 for their block equivalents. In
both cases, the cost is dominated by the single projection of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
and the matrix–vector multiplies in step 3, giving
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(T V)</annotation></semantics></math>
complexity with a small trial-dependent overhead.</p>
</div>
<div class="section level2">
<h2 id="complexity-and-memory">Complexity and Memory<a class="anchor" aria-label="anchor" href="#complexity-and-memory"></a>
</h2>
<ul>
<li>Projection / whitening:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mi>V</mi><msub><mi>K</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(T V K_z)</annotation></semantics></math>
arithmetic,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><msub><mi>K</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(T K_z)</annotation></semantics></math>
memory for confounds</li>
<li>Precomputation:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(T N)</annotation></semantics></math>
</li>
<li>Products (blocked):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(T V)</annotation></semantics></math>
with block size tuning</li>
<li>Closed-form solves:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(N V)</annotation></semantics></math>
with negligible constants (2×2 or 2K×2K systems)</li>
</ul>
<p>Compared to classical LSS
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
separate regressions), OASIS shaves off repeated projections and linear
solves, yielding substantial speedups when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is large.</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<ul>
<li>Mumford, J. A., Turner, B. O., Ashby, F. G., &amp; Poldrack, R. A.
(2012). Deconvolving BOLD activation in event-related designs for
multivoxel pattern classification analyses. <em>NeuroImage</em>, 59(3),
2636–2643.</li>
<li>fmrilss source files <code>R/oasis_glue.R</code> and
<code>src/oasis_core.cpp</code> (for implementation alignment).</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html" class="external-link">sessionInfo</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; R version 4.5.1 (2025-06-13)</span></span>
<span><span class="co">#&gt; Platform: x86_64-pc-linux-gnu</span></span>
<span><span class="co">#&gt; Running under: Ubuntu 24.04.3 LTS</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Matrix products: default</span></span>
<span><span class="co">#&gt; BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 </span></span>
<span><span class="co">#&gt; LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; locale:</span></span>
<span><span class="co">#&gt;  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       </span></span>
<span><span class="co">#&gt;  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   </span></span>
<span><span class="co">#&gt;  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          </span></span>
<span><span class="co">#&gt; [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; time zone: UTC</span></span>
<span><span class="co">#&gt; tzcode source: system (glibc)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; attached base packages:</span></span>
<span><span class="co">#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; loaded via a namespace (and not attached):</span></span>
<span><span class="co">#&gt;  [1] digest_0.6.37     desc_1.4.3        R6_2.6.1          fastmap_1.2.0    </span></span>
<span><span class="co">#&gt;  [5] xfun_0.53         cachem_1.1.0      knitr_1.50        htmltools_0.5.8.1</span></span>
<span><span class="co">#&gt;  [9] rmarkdown_2.29    lifecycle_1.0.4   cli_3.6.5         pkgdown_2.1.3    </span></span>
<span><span class="co">#&gt; [13] sass_0.4.10       textshaping_1.0.3 jquerylib_0.1.4   systemfonts_1.2.3</span></span>
<span><span class="co">#&gt; [17] compiler_4.5.1    tools_4.5.1       ragg_1.5.0        evaluate_1.0.5   </span></span>
<span><span class="co">#&gt; [21] bslib_0.9.0       yaml_2.3.10       jsonlite_2.0.0    rlang_1.1.6      </span></span>
<span><span class="co">#&gt; [25] fs_1.6.6</span></span></code></pre></div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Brad Buchsbaum.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
