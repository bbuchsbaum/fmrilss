diff --git a/src/lss_vox_hrf.cpp b/src/lss_vox_hrf.cpp
new file mode 100644
index 0000000..e3a2d7b
--- /dev/null
+++ b/src/lss_vox_hrf.cpp
@@ -0,0 +1,208 @@
+#include <Rcpp.h>
+using namespace Rcpp;
+
+// Helper: convert List of matrices to std::vector<NumericMatrix>
+static std::vector<NumericMatrix> as_matrix_list(const List& L, int expected_rows, int expected_cols) {
+  const int K = L.size();
+  std::vector<NumericMatrix> out;
+  out.reserve(K);
+  for (int k = 0; k < K; ++k) {
+    NumericMatrix Mk = as<NumericMatrix>(L[k]);
+    if (Mk.nrow() != expected_rows || Mk.ncol() != expected_cols) {
+      stop("basis_convolved[[%d]] has inconsistent dimensions: expected %d x %d, got %d x %d",
+           k + 1, expected_rows, expected_cols, Mk.nrow(), Mk.ncol());
+    }
+    out.push_back(Mk);
+  }
+  return out;
+}
+
+// [[Rcpp::export]]
+NumericMatrix lss_engine_vox_hrf_cpp(
+    const NumericMatrix& Y,              // n_time x n_vox
+    const NumericMatrix& coeffs,         // K x n_vox
+    const List& basis_convolved,         // length K; each n_time x n_trials
+    const NumericMatrix& Z               // n_time x pz (>=1; intercept allowed)
+) {
+  const int n_time   = Y.nrow();
+  const int n_vox    = Y.ncol();
+  const int K        = coeffs.nrow();
+  const int n_trials = as<NumericMatrix>(basis_convolved[0]).ncol();
+  const int pz       = Z.ncol();
+
+  // Validate list and sizes early
+  std::vector<NumericMatrix> Dk = as_matrix_list(basis_convolved, n_time, n_trials);
+  if (coeffs.ncol() != n_vox) stop("coeffs must be [K x n_vox] with n_vox matching Y");
+  if (pz < 1) stop("Z must have at least one column (e.g., intercept).");
+
+  NumericMatrix betas(n_trials, n_vox);
+
+  // Prepare access to stats::qr and stats::qr.coef once
+  Environment stats = Environment::namespace_env("stats");
+  Function qr_fn    = stats["qr"];
+  Function qr_coef  = stats["qr.coef"];
+
+  // Pre-allocate workspaces reused inside loops to reduce allocations
+  NumericMatrix Xv(n_time, n_trials);
+  std::vector<double> xall(n_time);
+
+  for (int v = 0; v < n_vox; ++v) {
+    // Combine per-basis convolved designs using voxel weights
+    std::fill(Xv.begin(), Xv.end(), 0.0);
+    for (int k = 0; k < K; ++k) {
+      const double w = coeffs(k, v);
+      if (w == 0.0) continue;
+      NumericMatrix& D = Dk[k];
+      for (int t = 0; t < n_time; ++t) {
+        for (int i = 0; i < n_trials; ++i) {
+          Xv(t, i) += w * D(t, i);
+        }
+      }
+    }
+
+    // Precompute "all others" sum per timepoint
+    for (int t = 0; t < n_time; ++t) {
+      double s = 0.0;
+      for (int i = 0; i < n_trials; ++i) s += Xv(t, i);
+      xall[t] = s;
+    }
+
+    NumericVector yv = Y(_, v);
+
+    // Per-trial GLMs
+    for (int i = 0; i < n_trials; ++i) {
+      // Build Xdesign = [Z, Xi, (Xother if n_trials>1)]
+      const bool have_other = (n_trials > 1);
+      const int p = pz + 1 + (have_other ? 1 : 0);
+      NumericMatrix Xdesign(n_time, p);
+
+      // Copy Z
+      for (int c = 0; c < pz; ++c) {
+        for (int t = 0; t < n_time; ++t) {
+          Xdesign(t, c) = Z(t, c);
+        }
+      }
+      // Xi
+      for (int t = 0; t < n_time; ++t) {
+        Xdesign(t, pz) = Xv(t, i);
+      }
+      // Xother
+      if (have_other) {
+        for (int t = 0; t < n_time; ++t) {
+          Xdesign(t, pz + 1) = xall[t] - Xv(t, i);
+        }
+      }
+
+      // Solve via QR using R's LAPACK through stats::qr + stats::qr.coef
+      SEXP qrobj = qr_fn(Xdesign);
+      NumericVector coef = qr_coef(qrobj, yv);
+
+      // Take coefficient of Xi, which is at index pz (0-based) in coef
+      if (coef.size() > pz && R_finite(coef[pz])) {
+        betas(i, v) = coef[pz];
+      } else {
+        betas(i, v) = NA_REAL;
+      }
+    }
+  }
+
+  return betas;
+}
diff --git a/R/lss_with_hrf.R b/R/lss_with_hrf.R
index b1f3a1a..9f2d5a3 100644
--- a/R/lss_with_hrf.R
+++ b/R/lss_with_hrf.R
@@ -1,12 +1,16 @@
 #' Least Squares Separate with voxel-wise HRF (basis-weighted)
 #'
 #' Compute LSS trial-wise betas when each voxel has its own HRF formed
 #' as a linear combination of K basis kernels sampled on the TR grid.
 #'
 #' **Design & nuisance handling match `lss()`**:
 #'   - The trial-of-interest (Xi) and the sum of all other trials (Xother) are
 #'     included in each per-trial GLM.
 #'   - If `Nuisance` is supplied, it is projected out of **Y** and the trial
 #'     regressors before LSS (standard residualization). Experimental regressors
 #'     `Z` are *not* residualized, matching `lss()` documentation.
 #'   - If `Z` is `NULL`, an intercept-only design is used.
 #'
@@ -23,9 +27,11 @@
 #' @param Nuisance optional numeric matrix (n_time x q) of confounds to project out
 #' @param verbose logical; print progress every 1000 voxels
 #'
 #' @return numeric matrix (n_trials x n_vox) of trial-wise beta estimates
+#' @param method character: "r" (default, pure R) or "cpp" (C++ backend). If "cpp"
+#'   is requested but not available, falls back to "r".
 #' @examples
 #' \dontrun{
-#' # Minimal use:
+#' # Minimal use (R backend):
 #' betas <- lss_with_hrf(Y, onset_idx, durations, basis, coeffs, Z = NULL, Nuisance = NULL)
 #' }
 #' @keywords internal
 lss_with_hrf <- function(
   Y,
   onset_idx,
   durations = NULL,
   hrf_basis_kernels,
   coefficients,
   Z = NULL,
   Nuisance = NULL,
-  verbose = FALSE
+  verbose = FALSE,
+  method = c("r", "cpp")
 ) {
+  method <- match.arg(method)
   # ---- basic checks ----
   if (!is.matrix(Y)) stop("Y must be a matrix [n_time x n_vox].")
   if (!is.matrix(hrf_basis_kernels)) stop("hrf_basis_kernels must be a matrix [L x K].")
   if (!is.matrix(coefficients)) stop("coefficients must be a matrix [K x n_vox].")
@@ -73,6 +79,8 @@
   # ---- 2) Convolve events with each basis kernel -> list of n_time x n_trials ----
   basis_convolved <- vector("list", K)
   for (k in seq_len(K)) {
     bk <- as.numeric(hrf_basis_kernels[, k])
     out <- vapply(seq_len(n_trials), function(j) conv_open_trim(Xev[, j], bk),
                   numeric(n_time))
     storage.mode(out) <- "double"
     basis_convolved[[k]] <- out
   }
@@ -103,6 +111,25 @@
   colnames(betas) <- colnames(Y)
   rownames(betas) <- paste0("trial_", seq_len(n_trials))
 
+  # ---- optional: C++ backend ----
+  if (method == "cpp") {
+    # Check that compiled symbol exists; otherwise fall back
+    have_cpp <- FALSE
+    try({
+      get("lss_engine_vox_hrf_cpp", envir = asNamespace("fmrilss"))
+      have_cpp <- TRUE
+    }, silent = TRUE)
+
+    if (have_cpp) {
+      betas_cpp <- lss_engine_vox_hrf_cpp(
+        Y = Y,
+        coeffs = coefficients,
+        basis_convolved = basis_convolved,
+        Z = Z_use
+      )
+      dimnames(betas_cpp) <- dimnames(betas)
+      return(betas_cpp)
+    }
+  }
+
   # ---- 5) For each voxel, combine basis designs with that voxel's HRF weights ----
   for (v in seq_len(n_vox)) {
     wv <- as.numeric(coefficients[, v])  # length K
@@ -151,3 +178,20 @@
 
   betas
 }
diff --git a/R/zzz_rcpp.R b/R/zzz_rcpp.R
new file mode 100644
index 0000000..f2d411c
--- /dev/null
+++ b/R/zzz_rcpp.R
@@ -0,0 +1,7 @@
+# nocov start
+#' @useDynLib fmrilss, .registration = TRUE
+#' @importFrom Rcpp sourceCpp
+NULL
+# nocov end
diff --git b/tests/testthat/test-lss-with-hrf-cpp.R a/tests/testthat/test-lss-with-hrf-cpp.R
new file mode 100644
index 0000000..f0b7e1a
--- /dev/null
+++ b/tests/testthat/test-lss-with-hrf-cpp.R
@@ -0,0 +1,77 @@
+test_that("cpp backend matches R backend on a small problem", {
+  skip_on_cran()
+  # If the C++ symbol isn't built yet, skip
+  sym_avail <- "lss_engine_vox_hrf_cpp" %in% getNamespaceExports("fmrilss")
+  if (!sym_avail) skip("C++ backend not available in this build")
+
+  set.seed(2025)
+  n_time <- 90L; n_trials <- 8L; n_vox <- 6L
+  onset_idx <- as.integer(seq(6, n_time - 12, length.out = n_trials))
+  dur <- rep(2L, n_trials)
+
+  # Event matrix
+  Xev <- matrix(0, n_time, n_trials)
+  for (i in seq_len(n_trials)) {
+    i1 <- onset_idx[i]; i2 <- min(n_time, i1 + dur[i])
+    Xev[i1:i2, i] <- 1
+  }
+
+  # Basis (K=3) and random voxel weights
+  b1 <- c(0, 0.3, 0.9, 1.0, 0.6, 0.2, 0)
+  b2 <- c(0, 0.1, 0.4, 0.5, 0.3, 0.1, 0)
+  b3 <- c(0, 0.2, 0.5, 0.4, 0.25, 0.1, 0)
+  basis <- cbind(b1, b2, b3)
+  coeffs <- matrix(runif(3 * n_vox, 0.5, 1.5), nrow = 3L, ncol = n_vox)
+
+  # Build a reference X using average HRF to simulate Y
+  avg_hrf <- drop(basis %*% rowMeans(coeffs))
+  conv_open_trim <- function(x, k) {
+    as.numeric(stats::convolve(x, rev(as.numeric(k)), type = "open"))[seq_len(length(x))]
+  }
+  X_ref <- vapply(seq_len(n_trials), function(j) conv_open_trim(Xev[, j], avg_hrf),
+                  numeric(n_time))
+
+  # Regressors and nuisance
+  Z <- cbind(1, scale(seq_len(n_time)))
+  Nuis <- cbind(scale(sin(seq_len(n_time) / 9)), scale(cos(seq_len(n_time) / 10)))
+
+  # Simulate data
+  true_betas <- matrix(rnorm(n_trials * n_vox, sd = 0.6), n_trials, n_vox)
+  Y <- X_ref %*% true_betas + Z %*% matrix(rnorm(ncol(Z) * n_vox), ncol(Z), n_vox) +
+       matrix(rnorm(n_time * n_vox, sd = 0.5), n_time, n_vox) +
+       Nuis %*% matrix(rnorm(ncol(Nuis) * n_vox, sd = 0.2), ncol(Nuis), n_vox)
+
+  # Run both backends
+  beta_r <- fmrilss:::lss_with_hrf(
+    Y = Y,
+    onset_idx = onset_idx,
+    durations = dur,
+    hrf_basis_kernels = basis,
+    coefficients = coeffs,
+    Z = Z,
+    Nuisance = Nuis,
+    method = "r",
+    verbose = FALSE
+  )
+
+  beta_cpp <- fmrilss:::lss_with_hrf(
+    Y = Y,
+    onset_idx = onset_idx,
+    durations = dur,
+    hrf_basis_kernels = basis,
+    coefficients = coeffs,
+    Z = Z,
+    Nuisance = Nuis,
+    method = "cpp",
+    verbose = FALSE
+  )
+
+  expect_equal(beta_cpp, beta_r, tolerance = 1e-8)
+})
